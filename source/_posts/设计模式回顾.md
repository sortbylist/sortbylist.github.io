---
title: 设计模式回顾
date: 2017-02-09 11:41:02
tags: [Java,设计模式]
---

### 设计模式

#### 分类

##### 创建型模式

- 工厂方法模式
- 抽象工厂模式
- 单例模式
- 建造者模式
- 原型模式

##### 结构型模式

- 适配器模式
- 装饰器模式
- 代理模式
- 外观模式
- 桥接模式
- 组合模式
- 享元模式

##### 行为型模式

- 策略模式
- 模板方法模式
- 观察者模式
- 迭代子模式
- 责任链模式
- 命令模式
- 备忘录模式
- 状态模式
- 访问者模式
- 中介者模式
- 解释器模式
- 并发型模式
- 线程池模式

#### 六大原则

- 开闭原则（ Open Close principle ）

  > 开闭原则就是说**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。

- 里氏替换原则 （ Liskov Substitution Principle ）

  > 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

- 依赖倒转原则 （ Dependence Inversion Principle ）

  这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

- 接口隔离原则 （ Interface Segregation Principle ）

  这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思。

- 迪米特法则 （最少知道原则 ） （ Demeter Principle ）

  一个实体应当尽量少的与其他实体之间发生相互作用，使系统功能模块相对独立。

- 合成复用原则 （ Composite Reuse Principle ）

  尽量使用合成/聚合的方式，而不是使用继承。


#### 工厂方法模式 （ Factory Method ）

  建立一个工厂类，对实现了同一接口的一些类进行实例的创建。

```java
  public interface Sender {
    public void send();
  }

  public class MailSender implements Sender {
    @Override
    public void send() {
      //...
    }
  }

  public class SmsSender implements Sender {
    @Override
    public void send() {
      //...
    }
  }

  public class SendFactory {
    public static Sender produceMail() {
      return new MailSender();
    }
    
    public static Sender produceSms() {
      return new SmsSender();
    }
  }

  //test
  SendFactory.produceMail().send();
```

#### 抽象工厂模式 （ Abstract Factory ）

  工厂方法模式的一个问题就是类的创建依赖工厂类，如果要拓展，则需要修改工厂类，违背了开闭原则。使用抽象工厂模式，创建多个工厂类，增加新功能，就直接增加新的工厂类就可以了。

```java
  public interface Provider {
    public Sender produce();
  }

  public class SmsSendFactory implements Provider {
    @Override
    public Sender produce() {
      return new SmsSender();
    }
  }

  public class MailSendFactory implements Provider {
    @Override
    public Sender produce() {
      return new MailSender();
    }
  }

  //test
  new MailSendFactory().produce().send();
  new SmsSendFactory().produce().send();
```

#### 单例模式

```java
  //静态内部类保证调用getInstance()方法时才初始化，同时由jvm保证仅一次初始化
  public class SingleTon {
    private SingleTon() {
      //防止被实例化
    }
    private static class SingleTonFactory {
      private static SingleTon instance = new SingleTon();
    }
    
    public static SingleTon getInstance() {
      return SingleTonFactory.instance;
    }
    
    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */  
    public Object readResolve() {
      return getInstance();
    }
  }
```
```java
  //双重校验加volatile，保证jdk5以后不出现指令重排
  public class SingleTon {
    private volatile static SingleTon instance;
    private SingleTon() {
      
    }
    public static SingleTon getInstance() {
      if(instance == null) {
        synchronized (SingleTon.class) {
          if(instance == null) {
            instance = new SingleTon();
          }
        }
      }
      return instance;
    }
  }
```

#### 建造者模式（ Builder ）

  > 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的 Test 结合起来得到的。

```java
  public class MultiSender {
    private List<Sender> senderList;
    
    public MultiSender() {
      this(10);
    }
    
    public MultiSender(int size) {
      senderList = new ArrayList<>(size);
    }
    
    public List<Sender> getSenderList() {
      return senderList;
    }
    
    public static class Builder {
    	private List<MailSender> mailSenders = null;
      private List<SmsSender> smsSenders = null;
      public Builder() {
        this(10);
      }
      
      public Builder(int size) {
        mailSenders = new ArrayList<>(size);
        smsSenders = new ArrayList<>(size);
      }
      
      public Builder addMailSender(MailSender mailSender) {
        mailSenders.add(mailSender); 
        return this;
    	}
      
      public Builder addSmsSender(SmsSender smsSender) {
        smsSenders.add(smsSender);
        return this;
      }
      
      public Builder addSender(Sender sender) {
        if(sender instanceof MailSender) {
          this.addMailSender((MailSender)sender);
        } else if(sender instanceof SmsSender) {
          this.addSmsSender((SmsSender)sender);
        }
        return this;
      }
      
      public MultiSender build() {
        int size = mailSenders.size() + smsSenders.size();
        MultiSender sender = new MultiSender(size);
        List<Sender> senderList = sender.getSenderList();
        senderList.addAll(mailSenders);
        senderList.addAll(smsSenders);
        return sender;
      }
    }
  }

  public class SenderTest {
    public static void main(String[] args) {
      MultiSender.Builder build = new MultiSender.Builder();
      build.addSmsSender(new SmsSender());
      build.addMailSener(new MailSender());
      MultiSender sender = build.build();
      List<Sender> senders = sender.getSenderList();
      for(Sender sender : senders) {
        sender.send();
      }
    }
  }
```

#### 原型模式（ Prototype ）

  原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。在 Java 中，复制对象是通过 `clone()` 实现的。

```java
  public class Prototype implements Cloneable {
    public Object clone() throws CloneNotSupportedException {
      Prototype proto = (Prototype) super.clone();
      return proto;
    } 
  }
```

  **浅复制**：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
  **深复制**：将一个对象复制后，不论是基本数据类型还是引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。

```java
  public class Prototype implements Cloneable, Serializable {

    private static final long serialVersionUID = 1L;
    private String string;

    private SerializableObject obj;

    /* 浅复制 */
    public Object clone() throws CloneNotSupportedException {
      Prototype proto = (Prototype) super.clone();
      return proto;
    }

    /* 深复制 */
    public Object deepClone() throws IOException, ClassNotFoundException {

      /* 写入当前对象的二进制流 */
      ByteArrayOutputStream bos = new ByteArrayOutputStream();
      ObjectOutputStream oos = new ObjectOutputStream(bos);
      oos.writeObject(this);

      /* 读出二进制流产生的新对象 */
      ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
      ObjectInputStream ois = new ObjectInputStream(bis);
      return ois.readObject();
    }

    public String getString() {
      return string;
    }

    public void setString(String string) {
      this.string = string;
    }

    public SerializableObject getObj() {
      return obj;
    }

    public void setObj(SerializableObject obj) {
      this.obj = obj;
    }

  }

  class SerializableObject implements Serializable {
    private static final long serialVersionUID = 1L;
  }
```

#### 适配器模式（ Adapter ）

  适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 

-   类的适配器模式

    ```java
    public class Source {
      public void method1() {
        System.out.println("this is original method!");
      }
    }

    public interface Targetable {
      public void method1();
      public void method2();
    }

    public class Adapter extends Source implements Targetable {
      @Override
      public void method2() {
        System.out.println("this is the targetable method!");
      }
    }

    public class AdapterTest {
      public static void main(String[] args) {
        Targetable  target = new Adapter();
        target.method1();
        target.method2();
      }
    }
    //this is original method!
    //this is the targetable method!
    ```

    - 对象的适配器模式

      基本思路和类的适配器模式相同，只是将 Adapter 类作修改，这次不继承 Source 类，而是持有 Source 类的实例，以达到解决兼容性的问题。

    ```java
        public class Wrapper implements Targetable {
          private Source source;
          
          public Wrapper(Source source) {
            super();
            this.source = source;
          }
          
          @Override
          public void method2() {
            System.out.println("this is the targetable method!");  
          }
          
          @Override
          public void method1() {
            source.method1();
          }
        }

        public class AdapterTest {
          public static void main(String[] args) {
            Source source = new Source();
            Targetable target = new Wrapper(source);
            target.method1();
            target.method2();
          }
        }
        //this is original method!
        //this is the targetable method!
    ```

    - 接口的适配器模式

      借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法。而我们不和原始接口打交道，而是继承该抽象类，重写我们需要的方法就行。

      ```java
      public abstract class Wrapper implements Targetable {
        public void method1(){}
        public void method2(){}
      }

      public class TargetSub1 extends Wrapper {
        public void method2() {
          System.out.println("this is TargetSub1 method2!");
        }
      }

      public class TargetSub2 extends Wrapper {
        public void method2() {
          System.out.println("this is TargetSub2 method2!");
        }
      }

      public class TargetSubTest {
        public void main(String[] args) {
          Targetable target1 = new TargetSub1();
          Targetable target2 = new TargetSub2();

          target1.method2();
          target2.method2();
        }
      }
      //this is TargetSub1 method2!
      //this is TargetSub2 method2!
      ```

#### 装饰模式（ Decorator ）

  装饰模式是指给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。Java IO中的类就是运用了装饰模式，如

```java
  FileReader f = new FileReader(filename);
  BufferedReader b = new FileReader(f);
```

```java
  FileInputStream f = new FileInputStream(new File(filename));
  BufferedInputStream bi = new BufferedInputStream(f);
```

```java
  public interface Sourceable {
    public void method();
  }

  public class Source implements Sourceable {
    @Override
    public void method() {
      System.out.println("the original method!");
    }
  }

  public class Decorator implements Sourceable {
    private Sourceable source;

    public Decorator(Sourceable source) {
      super();
      this.source = source;
    }

    @Override
    public void method() {
      System.out.println("before decorator!");
      source.method();
      System.out.println("after decorator!");
    }
  }

  public class DecoratorTest {

    public static void main(String[] args) {
      Sourceable source = new Source();
      Sourceable obj = new Decorator(source);
      obj.method();
    }
  }
  //before decorator!
  //the original method!
  //after decorator!
```

#### 代理模式 （ Proxy ）

  代理模式就是多一个代理类出来，替原对象进行一些操作。

```java
    public interface Sourceable {
      public void method();
    }

    public class Source implements Sourceable {
      @Override
      public void method() {
        System.out.println("the original method!");
      }
    }

    public class Proxy implements Sourceable {
      private Source source;
      public Proxy() {
        super();
        this.source = new Source();
      }

      @Override
      public void method() {
        before();
        source.method();
        after();
      }

      private void atfer() {
        System.out.println("after proxy!");
      }
      private void before() {
        System.out.println("before proxy!");
      }
    }

    public class ProxyTest {
      public static void main(String[] args) {
        Sourceable source = new Proxy();
        source.method();
      }
    }
```

  装饰模式 （ Decorator ） 与代理模式 （ Proxy ）模式的区别

  装饰模式：`被装饰对象`对客户端透明，用于增强`被装饰对象`的功能。

  代理模式：`被代理对象`对客户端不透明，用于控制`被代理对象`的引用，起到限制作用。

#### 外观模式 （ Facade )

  > 外观模式是为了解决类与类之家的依赖关系的，像 Spring 一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个 Facade 类中，降低了类类之间的耦合度，该模式中没有涉及到接口

#### 桥接模式（ Bridge ）

  桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化。

#### 组合模式 （ Composite ）

  组合模式有时又叫**部分**-**整体**模式，在处理类似树形结构的问题时比较方便。

```java
  private class TreeNode {
    private String name;
    private TreeNode parent;
    private Vector<TreeNode> children;
    
    public TreeNode(String name) {
      this.name = name;
    }
    
    public String getName() {
      return name;
    }
    
    public void setName(String name) {
      this.name = name;
    }
    
    public TreeNode getParent() {
      return parent;
    }
    
    public void setParent(TreeNode parent) {
      this.parent = parent;
    }
    
    public void add(TreeNode node) {
      children.add(node);
    }
    
    public void remove(TreeNode node) {
      children.remove(node);
    }
    
    public Enumeration<TreeNode> getChildren() {
      return child.elements();
    }
  }

  public class Tree {
    TreeNode root = null;
    public Tree(String name) {
      root = new TreeNode(name);
    }
    public static void main(String[] args) {  
      Tree tree = new Tree("A");  
      TreeNode nodeB = new TreeNode("B");  
      TreeNode nodeC = new TreeNode("C");  

      nodeB.add(nodeC);  
      tree.root.add(nodeB);  
      System.out.println("build the tree finished!");  
    }  
  }
```

#### 享元模式（ Flyweight ）

  享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。

#### 策略模式（ Strategy ）

  策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。

#### 模板方法模式（ Template Method ）

  模板方法模式是指一个抽象类中，有一个主方法，再定义1到n个方法，可以时抽象的，也可以是实际方法，定义一个类，继承该抽象类，重写抽象方法。通过调用抽象类，实现对子类的调用。

#### 观察者模式（ Observer ）
