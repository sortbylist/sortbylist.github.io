---
title: 设计模式回顾
date: 2017-02-09 11:41:02
tags: [Java,设计模式]
---

### 设计模式

#### 分类

##### 创建型模式

- 工厂方法模式
- 抽象工厂模式
- 单例模式
- 建造者模式
- 原型模式

##### 结构型模式

- 适配器模式
- 装饰器模式
- 代理模式
- 外观模式
- 桥接模式
- 组合模式
- 享元模式

##### 行为型模式

- 策略模式
- 模板方法模式
- 观察者模式
- 迭代子模式
- 责任链模式
- 命令模式
- 备忘录模式
- 状态模式
- 访问者模式
- 中介者模式
- 解释器模式
- 并发型模式
- 线程池模式

#### 六大原则

- 开闭原则（ Open Close principle ）

  > 开闭原则就是说**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。

- 里氏替换原则 （ Liskov Substitution Principle ）

  > 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

- 依赖倒转原则 （ Dependence Inversion Principle ）

  这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

- 接口隔离原则 （ Interface Segregation Principle ）

  这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思。

- 迪米特法则 （最少知道原则 ） （ Demeter Principle ）

  一个实体应当尽量少的与其他实体之间发生相互作用，使系统功能模块相对独立。

- 合成复用原则 （ Composite Reuse Principle ）

  尽量使用合成/聚合的方式，而不是使用继承。


#### 工厂方法模式 （ Factory Method ）

  建立一个工厂类，对实现了同一接口的一些类进行实例的创建。

```java
  public interface Sender {
    public void send();
  }

  public class MailSender implements Sender {
    @Override
    public void send() {
      //...
    }
  }

  public class SmsSender implements Sender {
    @Override
    public void send() {
      //...
    }
  }

  public class SendFactory {
    public static Sender produceMail() {
      return new MailSender();
    }
    
    public static Sender produceSms() {
      return new SmsSender();
    }
  }

  //test
  SendFactory.produceMail().send();
```

- Jdk中的工厂方法模式
  - `java.lang.Proxy#newProxyInstance()`
  - `java.lang.Object#toString()`
  - `java.lang.Class#newInstance()`
  - `java.lang.reflect.Array#newInstance()`
  - `java.lang.reflect.Constructor#newInstance()`
  - `java.lang.Boolean#valueOf(String)`
  - `java.lang.Class#forName()`

#### 抽象工厂模式 （ Abstract Factory ）

  工厂方法模式的一个问题就是类的创建依赖工厂类，如果要拓展，则需要修改工厂类，违背了开闭原则。使用抽象工厂模式，创建多个工厂类，增加新功能，就直接增加新的工厂类就可以了。

```java
  public interface Provider {
    public Sender produce();
  }

  public class SmsSendFactory implements Provider {
    @Override
    public Sender produce() {
      return new SmsSender();
    }
  }

  public class MailSendFactory implements Provider {
    @Override
    public Sender produce() {
      return new MailSender();
    }
  }

  //test
  new MailSendFactory().produce().send();
  new SmsSendFactory().produce().send();
```

- Jdk中的抽象工厂模式
  - `java.util.Calendar#getInstance()
  - `java.util.Arrays#asList()`
  - `java.util.ResourceBundle#getBundle()`
  - `java.sql.DriverManager#getConnection()`
  - `java.sql.Connection#createStatement()`
  - `java.sql.Statement#executeQuery()`
  - `java.text.NumberFormat#getInstance()`
  - `javax.xml.transform.TransformerFactory#newInstance()`

#### 单例模式

```java
  //静态内部类保证调用getInstance()方法时才初始化，同时由jvm保证仅一次初始化
  public class SingleTon {
    private SingleTon() {
      //防止被实例化
    }
    private static class SingleTonFactory {
      private static SingleTon instance = new SingleTon();
    }
    
    public static SingleTon getInstance() {
      return SingleTonFactory.instance;
    }
    
    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */  
    public Object readResolve() {
      return getInstance();
    }
  }
```
```java
  //双重校验加volatile，保证jdk5以后不出现指令重排
  public class SingleTon {
    private volatile static SingleTon instance;
    private SingleTon() {
      
    }
    public static SingleTon getInstance() {
      if(instance == null) {
        synchronized (SingleTon.class) {
          if(instance == null) {
            instance = new SingleTon();
          }
        }
      }
      return instance;
    }
  }
```

<!-- more -->

- Jdk中的单例模式
  - `java.lang.Runtime#getRuntime()`
  - `java.awt.Toolkit#getDefaultToolkit()`
  - `java.awt.GraphicsEnvironment#getLocalGraphicsEnvironment()`
  - `java.awt.Desktop#getDesktop()`

#### 建造者模式（ Builder ）

  > 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的 Test 结合起来得到的。

```java
  public class MultiSender {
    private List<Sender> senderList;
    
    public MultiSender() {
      this(10);
    }
    
    public MultiSender(int size) {
      senderList = new ArrayList<>(size);
    }
    
    public List<Sender> getSenderList() {
      return senderList;
    }
    
    public static class Builder {
    	private List<MailSender> mailSenders = null;
      private List<SmsSender> smsSenders = null;
      public Builder() {
        this(10);
      }
      
      public Builder(int size) {
        mailSenders = new ArrayList<>(size);
        smsSenders = new ArrayList<>(size);
      }
      
      public Builder addMailSender(MailSender mailSender) {
        mailSenders.add(mailSender); 
        return this;
    	}
      
      public Builder addSmsSender(SmsSender smsSender) {
        smsSenders.add(smsSender);
        return this;
      }
      
      public Builder addSender(Sender sender) {
        if(sender instanceof MailSender) {
          this.addMailSender((MailSender)sender);
        } else if(sender instanceof SmsSender) {
          this.addSmsSender((SmsSender)sender);
        }
        return this;
      }
      
      public MultiSender build() {
        int size = mailSenders.size() + smsSenders.size();
        MultiSender sender = new MultiSender(size);
        List<Sender> senderList = sender.getSenderList();
        senderList.addAll(mailSenders);
        senderList.addAll(smsSenders);
        return sender;
      }
    }
  }

  public class SenderTest {
    public static void main(String[] args) {
      MultiSender.Builder build = new MultiSender.Builder();
      build.addSmsSender(new SmsSender());
      build.addMailSener(new MailSender());
      MultiSender sender = build.build();
      List<Sender> senders = sender.getSenderList();
      for(Sender sender : senders) {
        sender.send();
      }
    }
  }
```

- Jdk中的建造模式

     - `java.lang.StringBuilder#append()`

     - `java.lang.StringBuffer#append()`
    - `java.sql.PreparedStatement`
    - `javax.swing.GroupLayout.Group#addComponent()`

#### 原型模式（ Prototype ）

原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。在 Java 中，复制对象是通过 `clone()` 实现的。

```java
  public class Prototype implements Cloneable {
    public Object clone() throws CloneNotSupportedException {
      Prototype proto = (Prototype) super.clone();
      return proto;
    } 
  }
```

**浅复制**：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
**深复制**：将一个对象复制后，不论是基本数据类型还是引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。

```java
  public class Prototype implements Cloneable, Serializable {

    private static final long serialVersionUID = 1L;
    private String string;

    private SerializableObject obj;

    /* 浅复制 */
    public Object clone() throws CloneNotSupportedException {
      Prototype proto = (Prototype) super.clone();
      return proto;
    }

    /* 深复制 */
    public Object deepClone() throws IOException, ClassNotFoundException {

      /* 写入当前对象的二进制流 */
      ByteArrayOutputStream bos = new ByteArrayOutputStream();
      ObjectOutputStream oos = new ObjectOutputStream(bos);
      oos.writeObject(this);

      /* 读出二进制流产生的新对象 */
      ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
      ObjectInputStream ois = new ObjectInputStream(bis);
      return ois.readObject();
    }

    public String getString() {
      return string;
    }

    public void setString(String string) {
      this.string = string;
    }

    public SerializableObject getObj() {
      return obj;
    }

    public void setObj(SerializableObject obj) {
      this.obj = obj;
    }

  }

  class SerializableObject implements Serializable {
    private static final long serialVersionUID = 1L;
  }
```

- Jdk中的原型模式
  - `java.lang.Object#clone()`
  - `java.lang.Cloneable`

#### 适配器模式（ Adapter ）

适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 

- 类的适配器模式

  ```java
  public class Source {
      public void method1() {
          System.out.println("this is original method!");
      }
  }
  
  public interface Targetable {
      public void method1();
      public void method2();
  }
  
  public class Adapter extends Source implements Targetable {
      @Override
      public void method2() {
          System.out.println("this is the targetable method!");
      }
  }
  
  public class AdapterTest {
      public static void main(String[] args) {
          Targetable  target = new Adapter();
          target.method1();
          target.method2();
      }
  }
  //this is original method!
  //this is the targetable method!
  ```

- 对象的适配器模式

  基本思路和类的适配器模式相同，只是将 Adapter 类作修改，这次不继承 Source 类，而是持有 Source 类的实例，以达到解决兼容性的问题。

  ```java
  public class Wrapper implements Targetable {
      private Source source;
  
      public Wrapper(Source source) {
          super();
          this.source = source;
      }
  
      @Override
      public void method2() {
          System.out.println("this is the targetable method!");  
      }
  
      @Override
      public void method1() {
          source.method1();
      }
  }
  
  public class AdapterTest {
      public static void main(String[] args) {
          Source source = new Source();
          Targetable target = new Wrapper(source);
          target.method1();
          target.method2();
      }
  }
  //this is original method!
  //this is the targetable method!
  ```

- 接口的适配器模式

  借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法。而我们不和原始接口打交道，而是继承该抽象类，重写我们需要的方法就行。

  ```java
  public abstract class Wrapper implements Targetable {
    public void method1(){}
    public void method2(){}
  }
  
  public class TargetSub1 extends Wrapper {
    public void method2() {
      System.out.println("this is TargetSub1 method2!");
    }
  }
  
  public class TargetSub2 extends Wrapper {
    public void method2() {
      System.out.println("this is TargetSub2 method2!");
    }
  }
  
  public class TargetSubTest {
    public void main(String[] args) {
      Targetable target1 = new TargetSub1();
      Targetable target2 = new TargetSub2();
  
      target1.method2();
      target2.method2();
    }
  }
  //this is TargetSub1 method2!
  //this is TargetSub2 method2!
  ```

- Jdk中的适配器模式
  - `java.util.Arrays#asList()`
  - `javax.swing.JTable(TableModel)`
  - `java.io.InputStreamReader(InputStream)`
  - `java.io.OutputStreamWriter(OutputStream)`
  - `javax.xml.bind.annotation.adapters.XmlAdapter#marshal()`
  - `javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()`

#### 装饰模式（ Decorator ）

装饰模式是指给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。Java IO中的类就是运用了装饰模式，如

```java
  FileReader f = new FileReader(filename);
  BufferedReader b = new FileReader(f);
```

```java
  FileInputStream f = new FileInputStream(new File(filename));
  BufferedInputStream bi = new BufferedInputStream(f);
```

```java
  public interface Sourceable {
    public void method();
  }

  public class Source implements Sourceable {
    @Override
    public void method() {
      System.out.println("the original method!");
    }
  }

  public class Decorator implements Sourceable {
    private Sourceable source;

    public Decorator(Sourceable source) {
      super();
      this.source = source;
    }

    @Override
    public void method() {
      System.out.println("before decorator!");
      source.method();
      System.out.println("after decorator!");
    }
  }

  public class DecoratorTest {

    public static void main(String[] args) {
      Sourceable source = new Source();
      Sourceable obj = new Decorator(source);
      obj.method();
    }
  }
  //before decorator!
  //the original method!
  //after decorator!
```

- Jdk中的装饰器模式

  动态的给一个对象附加额外的功能，这也是子类的一种替代方式。可以看到，在创建一个类型的时候，同时也传入同一类型的对象。这在JDK里随处可见，你会发现它无处不在，所以下面这个列表只是一小部分。


  - `java.io.BufferedInputStream(InputStream)`
  - `java.io.DataInputStream(InputStream)`
  - `java.io.BufferedOutputStream(OutputStream)`
  - `java.util.zip.ZipOutputStream(OutputStream)`
  - `java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap]`

#### 代理模式 （ Proxy ）

  代理模式就是多一个代理类出来，替原对象进行一些操作。

```java
    public interface Sourceable {
      public void method();
    }

    public class Source implements Sourceable {
      @Override
      public void method() {
        System.out.println("the original method!");
      }
    }

    public class Proxy implements Sourceable {
      private Source source;
      public Proxy() {
        super();
        this.source = new Source();
      }

      @Override
      public void method() {
        before();
        source.method();
        after();
      }

      private void atfer() {
        System.out.println("after proxy!");
      }
      private void before() {
        System.out.println("before proxy!");
      }
    }

    public class ProxyTest {
      public static void main(String[] args) {
        Sourceable source = new Proxy();
        source.method();
      }
    }
```

  装饰模式 （ Decorator ） 与代理模式 （ Proxy ）模式的区别

  装饰模式：`被装饰对象`对客户端透明，用于增强`被装饰对象`的功能。

  代理模式：`被代理对象`对客户端不透明，用于控制`被代理对象`的引用，起到限制作用。

- Jdk中的代理模式
  - java.lang.reflect.Proxy
  - RMI

#### 外观模式 （ Facade )

  > 外观模式是为了解决类与类之家的依赖关系的，像 Spring 一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个 Facade 类中，降低了类类之间的耦合度，该模式中没有涉及到接口

- Jdk中的外观模式

  给一组组件，接口，抽象，或者子系统提供一个简单的接口。

  - java.lang.Class
  - javax.faces.webapp.FacesServlet


#### 桥接模式（ Bridge ）

  桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化。

- Jdk中的桥接模式
  - AWT
  - JDBC

#### 组合模式 （ Composite ）

组合模式有时又叫**部分**-**整体**模式，在处理类似树形结构的问题时比较方便。

使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数。


```java
  private class TreeNode {
    private String name;
    private TreeNode parent;
    private Vector<TreeNode> children;
    
    public TreeNode(String name) {
      this.name = name;
    }
    
    public String getName() {
      return name;
    }
    
    public void setName(String name) {
      this.name = name;
    }
    
    public TreeNode getParent() {
      return parent;
    }
    
    public void setParent(TreeNode parent) {
      this.parent = parent;
    }
    
    public void add(TreeNode node) {
      children.add(node);
    }
    
    public void remove(TreeNode node) {
      children.remove(node);
    }
    
    public Enumeration<TreeNode> getChildren() {
      return child.elements();
    }
  }

  public class Tree {
    TreeNode root = null;
    public Tree(String name) {
      root = new TreeNode(name);
    }
    public static void main(String[] args) {  
      Tree tree = new Tree("A");  
      TreeNode nodeB = new TreeNode("B");  
      TreeNode nodeC = new TreeNode("C");  

      nodeB.add(nodeC);  
      tree.root.add(nodeB);  
      System.out.println("build the tree finished!");  
    }  
  }
```

- Jdk中的组合模式
  - `javax.swing.JComponent#add(Component)`
  - `java.awt.Container#add(Component)`
  - `java.util.Map#putAll(Map)`
  - `java.util.List#addAll(Collection)`
  - `java.util.Set#addAll(Collection)`

#### 享元模式（ Flyweight ）

  享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。

- Jdk中的享元模式

  使用缓存来加速大量小对象的访问时间。

  - `java.lang.Integer#valueOf(int)`
  - `java.lang.Boolean#valueOf(boolean)`
  - `java.lang.Byte#valueOf(byte)`
  - `java.lang.Character#valueOf(char)`


#### 策略模式（ Strategy ）

  策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。

- Jdk中的策略模式

  使用这个模式来将一组算法封装成一系列对象。通过传递这些对象可以灵活的改变程序的功能。

  - `java.util.Comparator#compare()`
  - `javax.servlet.http.HttpServlet`
  - `javax.servlet.Filter#doFilter()`


#### 模板方法模式（ Template Method ）

  模板方法模式是指一个抽象类中，有一个主方法，再定义1到n个方法，可以是抽象的，也可以是实际方法，定义一个类，继承该抽象类，重写抽象方法。通过调用抽象类，实现对子类的调用。

- Jdk中的模板方法模式

  让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。

  - `java.util.Collections#sort()`
  - `java.io.InputStream#skip()`
  - `java.io.InputStream#read()`
  - `java.util.AbstractList#indexOf()`


#### 观察者模式（ Observer ）

包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承。

观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。

- Jdk中的观察者模式
  - `java.util.EventListener`
  - `javax.servlet.http.HttpSessionBindingListener`
  - `javax.servlet.http.HttpSessionAttributeListener`
  - `javax.faces.event.PhaseListener`

#### 迭代子模式 ( Iterator )

顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。

- Jdk中的迭代子模式

  提供一个一致的方法来顺序访问集合中的对象，这个方法与底层的集合的具体实现无关。


  - `java.util.Iterator`
  - `java.util.Enumeration`

#### 责任链模式 ( Chain of Responsibility )

责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。

```java
public interface Handler {
    public void operator();  
}

public abstract class AbstractHandler {
    private Handler next;
    public Handler getNext() {
        return handler;
    }
    public void setNext(Handler handler) {
        this.handler = handler;
    }
}

public class MyHandler extends AbstractHandler implements Handler {
    private String name;
    public MyHandler(String name) {
        this.name = name;
    }

    @Override
    public void operator() {
        System.out.println(name + " deal!");
        if (getNext() != null) {
            getNext().operator();
        }
    }
}

public class Test {

    public static void main(String[] args) {
        MyHandler h1 = new MyHandler("h1");
        MyHandler h2 = new MyHandler("h2");
        MyHandler h3 = new MyHandler("h3");

        h1.setNext(h2);
        h2.setNext(h3);

        h1.operator();
    }
}
```

- Jdk中的责任链模式
  - `java.util.logging.Logger#log()`
  - `javax.servlet.Filter#doFilter()`

#### 命令模式 ( Command )

命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。

```java
public interface Command<T> {
    T execute();
}

public class CommandImpl<T> implements Command<T> {
    private Receiver<T> receiver;
    public CommandImpl(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public T execute() {
        return receiver.execute();
    }
}

public class CommandInvoker<T> {
    private Command<T> command;

    //构造注入
    CommandInvoker(Command<T> command) {
        this.command = command;
    }

    //设值注入
    public void setCommand(Command<T> command) {
        this.command = command;
    }

    //业务方法，用于调用命令类的execute()方法
    public T call() {
        return command.execute();
    }
}

public interface Receiver<T> {
    T execute();
}

public class AddReceiver implements Receiver<Integer> {
    private int num1, num2;

    public AddReceiver(int num1, int num2) {
        this.num1 = num1;
        this.num2 = num2;
    }

    @Override
    public Integer execute() {
        return num1 + num2;
    }
}

public class CommandTest {
    public static void main(String[] args) {
        Receiver<Integer> receiver = new AddReceiver(1, 2);
        Command<Integer> command = new CommandImpl<>(receiver);

        CommandInvoker<Integer> invoker = new CommandInvoker<>(command);
        int result = invoker.call();
        System.out.println(result);
    }
}
```

- Jdk中的命令模式
  - `java.lang.Runnable`
  - `javax.swing.Action`

#### 备忘录模式 ( Memento )

主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象。

- Jdk中的备忘录模式

  生成对象状态的一个快照，以便对象可以恢复原始状态而不用暴露自身的内容。Date对象通过自身内部的一个long值来实现备忘录模式。

  - java.util.Date
  - java.io.Serializable


#### 状态模式 （ State )

当对象的状态改变时，同时改变其行为。

```java
abstract class State {
    //声明抽象业务方法，不同的具体状态类可以不同的实现  
    public abstract void handle();  
}

class ConcreteState extends State {
    public void handle() {
        //方法具体实现代码  
    }
}

class Context {
    private State state; //维持一个对抽象状态对象的引用  
    private int value; //其他属性值，该属性值的变化可能会导致对象状态发生变化  

    //设置状态对象  
    public void setState(State state) {
        this.state = state;  
    }

    public void request() {
        //其他代码  
        state.handle(); //调用状态对象的业务方法  
        //其他代码  
    }
    
    public State checkState() {
        if(value == 1) {
            this.state = new State1();
        } else if(value ==2) {
            this.state == new State2();
        }
        return this.state;
    }
}
```

- Jdk中的状态模式

  通过改变对象内部的状态，使得你可以在运行时动态改变一个对象的行为。

  - `java.util.Iterator`
  - `javax.faces.lifecycle.LifeCycle#execute()`


#### 访问者模式

访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。

访问者模式算是最复杂也是最难以理解的一种模式了。它表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。

涉及角色：

1.Visitor 抽象访问者角色，为该对象结构中具体元素角色声明一个访问操作接口。该操作接口的名字和参数标识了发送访问请求给具体访问者的具体元素角色，这样访问者就可以通过该元素角色的特定接口直接访问它。

2.ConcreteVisitor.具体访问者角色，实现Visitor声明的接口。

3.Element 定义一个接受访问操作(accept())，它以一个访问者(Visitor)作为参数。

4.ConcreteElement 具体元素，实现了抽象元素(Element)所定义的接受操作接口。

5.ObjectStructure 结构对象角色，这是使用访问者模式必备的角色。它具备以下特性：能枚举它的元素；可以提供一个高层接口以允许访问者访问它的元素；如有需要，可以设计成一个复合对象或者一个聚集（如一个列表或无序集合）。

```java
abstract class Element
{
    public abstract void accept(IVisitor visitor);
    public abstract void doSomething();
}

class ConcreteElement1 extends Element{
    public void doSomething(){
        System.out.println("这是元素1");
    }
    public void accept(IVisitor visitor){
        visitor.visit(this);
    }
}

class ConcreteElement2 extends Element{
    public void doSomething(){
        System.out.println("这是元素2");
    }
    public void accept(IVisitor visitor){
        visitor.visit(this);
    }
}

interface IVisitor{
    public void visit(ConcreteElement1el1);
    public void visit(ConcreteElement2el2);
}

class Visitor implements IVisitor{
    public void visit(ConcreteElement1 el1){
        el1.doSomething();
    }
    public void visit(ConcreteElement2 el2){
        el2.doSomething();
    }
}

class ObjectStruture{
    public static List<Element> getList(){
        List<Element>list = new ArrayList<Element>();
        Random ran = newRandom();
        for(int i = 0 ; i < 10 ; i ++){
            int a=ran.nextInt(100);
            if(a>50){
                list.add (newConcreteElement1());
            }else{
                list.add (newConcreteElement2());
            }
        }
        return list;
    }
}

public class Client{
    public static void main (String[]args){
        List<Element> list = ObjectStruture.getList();
        for(Elemente:list){
            e.accept(newVisitor());
        }
    }
}
```
- Jdk中的访问者模式

  提供一个方便的可维护的方式来操作一组对象。它使得你在不改变操作的对象前提下，可以修改或者扩展对象的行为。

  - `javax.lang.model.element.Element` and `javax.lang.model.element.ElementVisitor`
  - `javax.lang.model.type.TypeMirror` and `javax.lang.model.type.TypeVisitor`


#### 中介者模式 ( Mediator )

用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

- Jdk中的中介者模式

  通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。

  - `java.util.Timer`
  - `java.util.concurrent.Executor#execute()`
  - `java.util.concurrent.ExecutorService#submit()`
  - `java.lang.reflect.Method#invoke()`


#### 解释器模式 ( Interpreter )

给定一种语言，定义他的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中句子。

解释器模式是一个比较少用的模式。

- Jdk中的解释器模式

  这个模式通常定义了一个语言的语法，然后解析相应语法的语句。

  - 
  - `java.util.Pattern`
  - `java.text.Normalizer`
  - `java.text.Format`