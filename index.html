<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sortbylist.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java coder">
<meta property="og:type" content="website">
<meta property="og:title" content="书生小栈">
<meta property="og:url" content="http://sortbylist.github.io/index.html">
<meta property="og:site_name" content="书生小栈">
<meta property="og:description" content="Java coder">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jerry Lee">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://sortbylist.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>书生小栈</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">书生小栈</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sortbylist.github.io/2019/03/27/java-io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content="Java coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书生小栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/27/java-io/" class="post-title-link" itemprop="url">Java IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-27 10:18:11" itemprop="dateCreated datePublished" datetime="2019-03-27T10:18:11+08:00">2019-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-08 17:02:30" itemprop="dateModified" datetime="2019-04-08T17:02:30+08:00">2019-04-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013695159#articleHeader13">Java IO 考点及资料整理</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html">深入分析 Java I&#x2F;O 的工作机制</a></p>
</blockquote>
<p><code>java.io</code>包主要涉及文件访问、网络数据流、内存缓冲访问、线程内部通信（管道）、缓冲、过滤、解析、读写文件（Readers&#x2F;Writers）、读写基本类型数据（long，int etc）、读写对象等输入输出。</p>
<h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h2 id="InputStream字节输入流"><a href="#InputStream字节输入流" class="headerlink" title="InputStream字节输入流"></a><code>InputStream</code>字节输入流</h2><ul>
<li>ByteArrayInputStream</li>
<li>FileInputStream</li>
<li>FilterInputStream<ul>
<li>BufferedInputStream</li>
<li>DataInputStream</li>
<li><del>LineNumberInputStream</del></li>
<li>PushbackInputStream</li>
</ul>
</li>
<li>ObjectInputStream</li>
<li>PipedInputStream</li>
<li>SequenceInputStream</li>
<li>StringBufferStream</li>
</ul>
<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">             <span class="type">int</span>     <span class="title function_">available</span><span class="params">()</span>;</span><br><span class="line">             <span class="keyword">void</span>    <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">             <span class="keyword">void</span>    <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readlimit)</span>;</span><br><span class="line">             <span class="type">boolean</span> <span class="title function_">markSupported</span><span class="params">()</span>;</span><br><span class="line">             <span class="type">int</span>     <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span>;</span><br><span class="line"><span class="keyword">abstract</span>     <span class="type">int</span>     <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">             <span class="type">int</span>     <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span>    <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line">             <span class="type">long</span>    <span class="title function_">skip</span><span class="params">(<span class="type">long</span> byteCount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h3><p>ByteArrayInputStream 是字节数组输入流。它继承于InputStream。<br>它包含一个内部缓冲区，该缓冲区包含从流中读取的字节；通俗点说，它的内部缓冲区就是一个字节数组，而ByteArrayInputStream本质就是通过字节数组来实现的。<br>我们都知道，InputStream通过read()向外提供接口，供它们来读取字节数据；而ByteArrayInputStream 的内部额外的定义了一个计数器，它被用来跟踪 read() 方法要读取的下一个字节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数;</span></span><br><span class="line">ByteArrayInputStream(<span class="type">byte</span>[] buf);</span><br><span class="line">ByteArrayInputStream(<span class="type">byte</span>[] buf, <span class="type">int</span> offset, <span class="type">int</span> length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="type">int</span>         <span class="title function_">available</span><span class="params">()</span>;</span><br><span class="line">             <span class="keyword">void</span>        <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span>        <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readlimit)</span>;</span><br><span class="line">             <span class="type">boolean</span>     <span class="title function_">markSupported</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="type">int</span>         <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="type">int</span>         <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span>        <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="type">long</span>        <span class="title function_">skip</span><span class="params">(<span class="type">long</span> byteCount)</span>;</span><br></pre></td></tr></table></figure>

<p>ByteArrayInputStream实际上是通过“字节数组”去保存数据。</p>
<ul>
<li>通过ByteArrayInputStream(byte buf[]) 或 ByteArrayInputStream(byte buf[], int offset, int length) ，我们可以根据buf数组来创建字节流对象。</li>
<li>read()的作用是从字节流中“读取下一个字节”。</li>
<li>read(byte[] buffer, int offset, int length)的作用是从字节流读取字节数据，并写入到字节数组buffer中。offset是将字节写入到buffer的起始位置，length是写入的字节的长度。</li>
<li>markSupported()是判断字节流是否支持“标记功能”。它一直返回true。</li>
<li>mark(int readlimit)的作用是记录标记位置。记录标记位置之后，某一时刻调用reset()则将“字节流下一个被读取的位置”重置到“mark(int readlimit)所标记的位置”；也就是说，reset()之后再读取字节流时，是从mark(int readlimit)所标记的位置开始读取。</li>
</ul>
<h3 id="PipedInputStream"><a href="#PipedInputStream" class="headerlink" title="PipedInputStream"></a>PipedInputStream</h3><p>在java中，<strong>PipedOutputStream</strong>和<strong>PipedInputStream</strong>分别是管道输出流和管道输入流。<br>它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。<br>使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以实现，线程A和线程B的通信。</p>
<p>PipedInputStream类中属性有<code>closedByWriter</code>、<code>closedByReader</code>、<code>connected</code>、<code>readSide</code>、<code>writeSide</code>、<code>buffer</code>、<code>in</code>、<code>out</code>，分别代码被写入线程关闭连接，被读取线程关闭连接，是否连接，读取线程，写入线程，内部缓冲byte数组，写入数，读取数。通过协调读取和写入线程，一方面从PipedOutputStream接收数据，一方面当调用<code>read()</code>、<code>read(byte[], int, int)</code>方法是从内部缓存byte数组中读取数据。</p>
<h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p>ObjectInputStream 和 ObjectOutputStream 的作用是，<strong>对基本数据和对象进行序列化操作支持。</strong></p>
<p>当我们需要读取ObjectOutputStream存储的“基本数据或对象”时，可以创建“文件输入流”对应的ObjectInputStream，进而读取出这些“基本数据或对象”。</p>
<p>注意： 只有支持 java.io.Serializable 或 java.io.Externalizable 接口的对象才能被ObjectInputStream&#x2F;ObjectOutputStream所操作！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数;</span></span><br><span class="line">ObjectInputStream(InputStream input);</span><br><span class="line"></span><br><span class="line"><span class="comment">//public函数;</span></span><br><span class="line"><span class="type">int</span>     <span class="title function_">available</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">defaultReadObject</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span>     <span class="title function_">readBoolean</span><span class="params">()</span>;</span><br><span class="line"><span class="type">byte</span>     <span class="title function_">readByte</span><span class="params">()</span>;</span><br><span class="line"><span class="type">char</span>     <span class="title function_">readChar</span><span class="params">()</span>;</span><br><span class="line"><span class="type">double</span>     <span class="title function_">readDouble</span><span class="params">()</span>;</span><br><span class="line">ObjectInputStream.GetField     <span class="title function_">readFields</span><span class="params">()</span>;</span><br><span class="line"><span class="type">float</span>     <span class="title function_">readFloat</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[] dst)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[] dst, <span class="type">int</span> offset, <span class="type">int</span> byteCount)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">readInt</span><span class="params">()</span>;</span><br><span class="line">String     <span class="title function_">readLine</span><span class="params">()</span>;</span><br><span class="line"><span class="type">long</span>     <span class="title function_">readLong</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">final</span> Object     <span class="title function_">readObject</span><span class="params">()</span>;</span><br><span class="line"><span class="type">short</span>     <span class="title function_">readShort</span><span class="params">()</span>;</span><br><span class="line">String     <span class="title function_">readUTF</span><span class="params">()</span>;</span><br><span class="line">Object     <span class="title function_">readUnshared</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">readUnsignedByte</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">readUnsignedShort</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span>     <span class="title function_">registerValidation</span><span class="params">(ObjectInputValidation object, <span class="type">int</span> priority)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">skipBytes</span><span class="params">(<span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>FileInputStream 是文件输入流，它继承于InputStream。<br>通常，我们使用FileInputStream从某个文件中获得输入字节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream(File file); <span class="comment">// 构造函数1：创建“File对象”对应的“文件输入流”</span></span><br><span class="line">FileInputStream(FileDescriptor fd); <span class="comment">// 构造函数2：创建“文件描述符”对应的“文件输入流”</span></span><br><span class="line">FileInputStream(String path); <span class="comment">// 构造函数3：创建“文件(路径为path)”对应的“文件输入流”</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">available</span><span class="params">()</span>; <span class="comment">// 返回“剩余的可读取的字节数”或者“skip的字节数”</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>; <span class="comment">// 关闭“文件输入流”</span></span><br><span class="line">FileChannel <span class="title function_">getChannel</span><span class="params">()</span>; <span class="comment">// 返回“FileChannel”</span></span><br><span class="line"><span class="keyword">final</span> FileDescriptor <span class="title function_">getFD</span><span class="params">()</span>; <span class="comment">// 返回“文件描述符”</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>; <span class="comment">// 返回“文件输入流”的下一个字节</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> byteOffset, <span class="type">int</span> byteCount)</span>; <span class="comment">// 读取“文件输入流”的数据并存在到buffer，从byteOffset开始存储，存储长度是byteCount。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">skip</span><span class="params">(<span class="type">long</span> byteCount)</span>; <span class="comment">// 跳过byteCount个字节</span></span><br></pre></td></tr></table></figure>
<h3 id="FilterInputStream"><a href="#FilterInputStream" class="headerlink" title="FilterInputStream"></a>FilterInputStream</h3><p><strong>FilterInputStream</strong> 的作用是用来“<strong>封装其它的输入流，并为它们提供额外的功能</strong>”。它的常用的子类有BufferedInputStream和DataInputStream。</p>
<p><strong>BufferedInputStream</strong>的作用就是为“输入流提供缓冲功能，以及mark()和reset()功能”。</p>
<p><strong>DataInputStream</strong> 是用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。应用程序可以使用DataOutputStream(数据输出流)写入由DataInputStream(数据输入流)读取的数据。</p>
<p><strong>FilterInputStream</strong>很明显使用了<strong>装饰器模式 ( Decorator )</strong>。</p>
<h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h3><p>BufferedInputStream 是缓冲输入流。它继承于<strong>FilterInputStream</strong>。</p>
<p>BufferedInputStream 的作用是为另一个输入流添加一些功能，例如，提供“缓冲功能”以及支持“mark()标记”和“reset()重置方法”。</p>
<p>BufferedInputStream 本质上是通过一个内部缓冲区数组实现的。例如，在新建某输入流对应的BufferedInputStream后，当我们通过read()读取输入流的数据时，BufferedInputStream会将该输入流的数据分批的填入到缓冲区中。每当缓冲区中的数据被读完之后，输入流会再次填充数据缓冲区；如此反复，直到我们读完输入流数据位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream(InputStream in);</span><br><span class="line">BufferedInputStream(InputStream in, <span class="type">int</span> size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="type">int</span>     <span class="title function_">available</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span>     <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readlimit)</span>;</span><br><span class="line"><span class="type">boolean</span>     <span class="title function_">markSupported</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="type">int</span>     <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="type">int</span>     <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> byteCount)</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span>     <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="type">long</span>     <span class="title function_">skip</span><span class="params">(<span class="type">long</span> byteCount)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h3><p>DataInputStream 是数据输入流。它继承于FilterInputStream。</p>
<p>DataInputStream 是**用来装饰其它输入流，它“允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型”。**应用程序可以使用DataOutputStream(数据输出流)写入由DataInputStream(数据输入流)读取的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream(InputStream in); </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> length)</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readBoolean</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">byte</span> <span class="title function_">readByte</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">char</span> <span class="title function_">readChar</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> <span class="title function_">readFloat</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[] dst)</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[] dst, <span class="type">int</span> offset, <span class="type">int</span> byteCount)</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> String <span class="title function_">readLine</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">readLong</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">short</span> <span class="title function_">readShort</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> String <span class="title function_">readUTF</span><span class="params">(DataInput in)</span>; </span><br><span class="line"><span class="keyword">final</span> String <span class="title function_">readUTF</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">readUnsignedByte</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">readUnsignedShort</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">skipBytes</span><span class="params">(<span class="type">int</span> count)</span>; </span><br></pre></td></tr></table></figure>


<h2 id="OutputStream字节输出流"><a href="#OutputStream字节输出流" class="headerlink" title="OutputStream字节输出流"></a><code>OutputStream</code>字节输出流</h2><ul>
<li>ByteArrayOutputStream</li>
<li>FileOutputStream</li>
<li>FilterOutputStream<ul>
<li>BufferedOutputStream</li>
<li>DataOutputStream</li>
<li>PrintStream</li>
</ul>
</li>
<li>ObjectOutputStream</li>
<li>PipedOutputStream</li>
</ul>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable &#123;</span><br><span class="line">         <span class="keyword">void</span>    <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">         <span class="keyword">void</span>    <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line">         <span class="keyword">void</span>    <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> count)</span>;</span><br><span class="line">         <span class="keyword">void</span>    <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] buffer)</span>;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span>    <span class="title function_">write</span><span class="params">(<span class="type">int</span> oneByte)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h3><p>ByteArrayOutputStream 是字节数组输出流。它继承于OutputStream。<br>ByteArrayOutputStream 中的数据被写入一个 byte 数组。缓冲区会随着数据的不断写入而自动增长，“新容量”的初始化 &#x3D; “旧容量”x2。可使用 toByteArray() 和 toString() 获取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数;</span></span><br><span class="line">ByteArrayOutputStream();</span><br><span class="line">ByteArrayOutputStream(<span class="type">int</span> size);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">void</span>    <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span>    <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line">             <span class="type">int</span>     <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="type">byte</span>[]  toByteArray();</span><br><span class="line">             String  <span class="title function_">toString</span><span class="params">(<span class="type">int</span> hibyte)</span>;</span><br><span class="line">             String  <span class="title function_">toString</span><span class="params">(String charsetName)</span>;</span><br><span class="line">             String  <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span>    <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span>    <span class="title function_">write</span><span class="params">(<span class="type">int</span> oneByte)</span>;</span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span>    <span class="title function_">writeTo</span><span class="params">(OutputStream out)</span>;</span><br></pre></td></tr></table></figure>

<p>ByteArrayOutputStream实际上是将字节数据写入到“字节数组”中去。</p>
<ul>
<li>通过ByteArrayOutputStream()创建的“字节数组输出流”对应的字节数组大小是32。</li>
<li>通过ByteArrayOutputStream(int size) 创建“字节数组输出流”，它对应的字节数组大小是size。</li>
<li>write(int oneByte)的作用将int类型的oneByte换成byte类型，然后写入到输出流中。</li>
<li>write(byte[] buffer, int offset, int len) 是将字节数组buffer写入到输出流中，offset是从buffer中读取数据的起始偏移位置，len是读取的长度。</li>
<li>writeTo(OutputStream out) 将该“字节数组输出流”的数据全部写入到“输出流out”中。</li>
</ul>
<h3 id="PipedOutputStream"><a href="#PipedOutputStream" class="headerlink" title="PipedOutputStream"></a>PipedOutputStream</h3><p>在java中，<strong>PipedOutputStream</strong>和<strong>PipedInputStream</strong>分别是管道输出流和管道输入流。<br>它们的作用是让多线程可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedOutputStream和PipedInputStream配套使用。<br>使用管道通信时，大致的流程是：我们在线程A中向PipedOutputStream中写入数据，这些数据会自动的发送到与PipedOutputStream对应的PipedInputStream中，进而存储在PipedInputStream的缓冲中；此时，线程B通过读取PipedInputStream中的数据。就可以实现，线程A和线程B的通信。</p>
<p>PipedOutputStream类中持有PipedInputStream实例，调用write&#x2F;flush等方法时均对PipedInputStream实例进行操作。</p>
<h3 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h3><p>ObjectInputStream 和 ObjectOutputStream 的作用是，<strong>对基本数据和对象进行序列化操作支持。</strong></p>
<p>创建“文件输出流”对应的ObjectOutputStream对象，该ObjectOutputStream对象能提供对“基本数据或对象”的持久存储。</p>
<p>注意： 只有支持 java.io.Serializable 或 java.io.Externalizable 接口的对象才能被ObjectInputStream&#x2F;ObjectOutputStream所操作！</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数;</span></span><br><span class="line">ObjectOutputStream(OutputStream output);</span><br><span class="line"></span><br><span class="line"><span class="comment">// public函数;</span></span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">defaultWriteObject</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line">ObjectOutputStream.PutField     <span class="title function_">putFields</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">useProtocolVersion</span><span class="params">(<span class="type">int</span> version)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(<span class="type">int</span> value)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeBoolean</span><span class="params">(<span class="type">boolean</span> value)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeByte</span><span class="params">(<span class="type">int</span> value)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeBytes</span><span class="params">(String value)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeChar</span><span class="params">(<span class="type">int</span> value)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeChars</span><span class="params">(String value)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeDouble</span><span class="params">(<span class="type">double</span> value)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeFields</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeFloat</span><span class="params">(<span class="type">float</span> value)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeInt</span><span class="params">(<span class="type">int</span> value)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeLong</span><span class="params">(<span class="type">long</span> value)</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeObject</span><span class="params">(Object object)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeShort</span><span class="params">(<span class="type">int</span> value)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeUTF</span><span class="params">(String value)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeUnshared</span><span class="params">(Object object)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>FileOutputStream 是文件输出流，它继承于OutputStream。</p>
<p>通常，我们使用FileOutputStream 将数据写入 File 或 FileDescriptor 的输出流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(File file); <span class="comment">// 构造函数1：创建“File对象”对应的“文件输入流”；默认“追加模式”是false，即“写到输出的流内容”不是以追加的方式添加到文件中。</span></span><br><span class="line">FileOutputStream(File file, <span class="type">boolean</span> append); <span class="comment">// 构造函数2：创建“File对象”对应的“文件输入流”；指定“追加模式”。</span></span><br><span class="line">FileOutputStream(FileDescriptor fd); <span class="comment">// 构造函数3：创建“文件描述符”对应的“文件输入流”；默认“追加模式”是false，即“写到输出的流内容”不是以追加的方式添加到文件中。</span></span><br><span class="line">FileOutputStream(String path); <span class="comment">// 构造函数4：创建“文件(路径为path)”对应的“文件输入流”；默认“追加模式”是false，即“写到输出的流内容”不是以追加的方式添加到文件中。</span></span><br><span class="line">FileOutputStream(String path, <span class="type">boolean</span> append); <span class="comment">// 构造函数5：创建“文件(路径为path)”对应的“文件输入流”；指定“追加模式”。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>; <span class="comment">// 关闭“输出流”</span></span><br><span class="line">FileChannel <span class="title function_">getChannel</span><span class="params">()</span>; <span class="comment">// 返回“FileChannel”</span></span><br><span class="line"><span class="keyword">final</span> FileDescriptor <span class="title function_">getFD</span><span class="params">()</span>; <span class="comment">// 返回“文件描述符”</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> byteOffset, <span class="type">int</span> byteCount)</span>; <span class="comment">// 将buffer写入到“文件输出流”中，从buffer的byteOffset开始写，写入长度是byteCount。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> oneByte)</span>; <span class="comment">// 写入字节oneByte到“文件输出流”中</span></span><br></pre></td></tr></table></figure>

<h3 id="FilterOutputStream"><a href="#FilterOutputStream" class="headerlink" title="FilterOutputStream"></a>FilterOutputStream</h3><p>FilterOutputStream 的作用是用来“封装其它的输出流，并为它们提供额外的功能”。它主要包括BufferedOutputStream, DataOutputStream和PrintStream。</p>
<p>BufferedOutputStream的作用就是为“输出流提供缓冲功能”。</p>
<p>DataOutputStream 是用来装饰其它输出流，将DataOutputStream和DataInputStream输入流配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”。</p>
<p>PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p>
<p><strong>FilteroutputStream</strong>很明显使用了<strong>装饰器模式 ( Decorator )</strong>。</p>
<h3 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h3><p>BufferedOutputStream 是缓冲输出流。它继承于FilterOutputStream。</p>
<p>BufferedOutputStream 的作用是为另一个输出流提供“缓冲功能”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedOutputStream(OutputStream out); </span><br><span class="line">BufferedOutputStream(OutputStream out, <span class="type">int</span> size); </span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> length)</span>; </span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> oneByte)</span>; </span><br></pre></td></tr></table></figure>

<p>BufferedOutputStream的源码非常简单，这里就BufferedOutputStream的思想进行简单说明：BufferedOutputStream通过字节数组来缓冲数据，当缓冲区满或者用户调用flush()函数时，它就会将缓冲区的数据写入到输出流中。</p>
<h3 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h3><p><strong>DataOutputStream</strong> 是数据输出流。它继承于FilterOutputStream。</p>
<p><strong>DataOutputStream</strong> 是用来装饰其它输出流，将DataOutputStream和<strong>DataInputStream</strong>输入流配合使用，“允许应用程序以与机器无关方式从底层输入流中读写基本 Java 数据类型”。</p>
<h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><p>PrintStream 是打印输出流，它继承于FilterOutputStream。</p>
<p>PrintStream 是用来装饰其它输出流。它能为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p>
<p>与其他输出流不同，PrintStream 永远不会抛出 IOException；它产生的IOException会被自身的函数所捕获并设置错误标记， 用户可以通过 checkError() 返回错误标记，从而查看PrintStream内部是否产生了IOException。</p>
<p>另外，<strong>PrintStream 提供了自动flush 和 字符集设置功能</strong>。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 将“输出流out”作为PrintStream的输出流，不会自动flush，并且采用默认字符集</span></span><br><span class="line"><span class="comment">// 所谓“自动flush”，就是每次执行print(); , println(); , write(); 函数，都会调用flush(); 函数；</span></span><br><span class="line"><span class="comment">// 而“不自动flush”，则需要我们手动调用flush(); 接口。</span></span><br><span class="line">PrintStream(OutputStream out); </span><br><span class="line"><span class="comment">// 将“输出流out”作为PrintStream的输出流，自动flush，并且采用默认字符集。</span></span><br><span class="line">PrintStream(OutputStream out, <span class="type">boolean</span> autoFlush); </span><br><span class="line"><span class="comment">// 将“输出流out”作为PrintStream的输出流，自动flush，采用charsetName字符集。</span></span><br><span class="line">PrintStream(OutputStream out, <span class="type">boolean</span> autoFlush, String charsetName); </span><br><span class="line"><span class="comment">// 创建file对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用默认字符集。</span></span><br><span class="line">PrintStream(File file); </span><br><span class="line"><span class="comment">// 创建file对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用charsetName字符集。</span></span><br><span class="line">PrintStream(File file, String charsetName); </span><br><span class="line"><span class="comment">// 创建fileName对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用默认字符集。</span></span><br><span class="line">PrintStream(String fileName); </span><br><span class="line"><span class="comment">// 创建fileName对应的FileOutputStream，然后将该FileOutputStream作为PrintStream的输出流，不自动flush，采用charsetName字符集。</span></span><br><span class="line">PrintStream(String fileName, String charsetName); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将“字符c”追加到“PrintStream输出流中”</span></span><br><span class="line">PrintStream <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span>; </span><br><span class="line"><span class="comment">// 将“字符序列从start(包括); 到end(不包括); 的全部字符”追加到“PrintStream输出流中”</span></span><br><span class="line">PrintStream <span class="title function_">append</span><span class="params">(CharSequence charSequence, <span class="type">int</span> start, <span class="type">int</span> end)</span>; </span><br><span class="line"><span class="comment">// 将“字符序列的全部字符”追加到“PrintStream输出流中”</span></span><br><span class="line">PrintStream <span class="title function_">append</span><span class="params">(CharSequence charSequence)</span>; </span><br><span class="line"><span class="comment">// flush“PrintStream输出流缓冲中的数据”，并检查错误</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">checkError</span><span class="params">()</span>; </span><br><span class="line"><span class="comment">// 关闭“PrintStream输出流”</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>; </span><br><span class="line"><span class="comment">// flush“PrintStream输出流缓冲中的数据”。</span></span><br><span class="line"><span class="comment">// 例如，PrintStream装饰的是FileOutputStream，则调用flush时会将数据写入到文件中</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>; </span><br><span class="line"><span class="comment">// 根据“Locale值(区域属性); ”来格式化数据</span></span><br><span class="line">PrintStream <span class="title function_">format</span><span class="params">(Locale l, String format, Object... args)</span>; </span><br><span class="line"><span class="comment">// 根据“默认的Locale值(区域属性); ”来格式化数据</span></span><br><span class="line">PrintStream <span class="title function_">format</span><span class="params">(String format, Object... args)</span>; </span><br><span class="line"><span class="comment">// 将“float数据f对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">float</span> f)</span>; </span><br><span class="line"><span class="comment">// 将“double数据d对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> d)</span>; </span><br><span class="line"><span class="comment">// 将“字符串数据str”写入到“PrintStream输出流”中，print实际调用的是write函数</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>; </span><br><span class="line"><span class="comment">// 将“对象o对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object o)</span>; </span><br><span class="line"><span class="comment">// 将“字符c对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> c)</span>; </span><br><span class="line"><span class="comment">// 将“字符数组chars对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span>[] chars)</span>; </span><br><span class="line"><span class="comment">// 将“long型数据l对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">long</span> l)</span>; </span><br><span class="line"><span class="comment">// 将“int数据i对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span>; </span><br><span class="line"><span class="comment">// 将“boolean数据b对应的字符串”写入到“PrintStream输出流”中，print实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> b)</span>; </span><br><span class="line"><span class="comment">// 将“数据args”根据“Locale值(区域属性); ”按照format格式化，并写入到“PrintStream输出流”中</span></span><br><span class="line">PrintStream <span class="title function_">printf</span><span class="params">(Locale l, String format, Object... args)</span>; </span><br><span class="line"><span class="comment">// 将“数据args”根据“默认Locale值(区域属性); ”按照format格式化，并写入到“PrintStream输出流”中</span></span><br><span class="line">PrintStream <span class="title function_">printf</span><span class="params">(String format, Object... args)</span>; </span><br><span class="line"><span class="comment">// 将“换行符”写入到“PrintStream输出流”中，println实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">println</span><span class="params">()</span>; </span><br><span class="line"><span class="comment">// 将“float数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">float</span> f)</span>; </span><br><span class="line"><span class="comment">// 将“int数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">int</span> i)</span>; </span><br><span class="line"><span class="comment">// 将“long数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">long</span> l)</span>; </span><br><span class="line"><span class="comment">// 将“对象o对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object o)</span>; </span><br><span class="line"><span class="comment">// 将“字符数组chars对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span>[] chars)</span>; </span><br><span class="line"><span class="comment">// 将“字符串str+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String str)</span>; </span><br><span class="line"><span class="comment">// 将“字符c对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span> c)</span>; </span><br><span class="line"><span class="comment">// 将“double数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">double</span> d)</span>; </span><br><span class="line"><span class="comment">// 将“boolean数据对应的字符串+换行符”写入到“PrintStream输出流”中，println实际调用的是write函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">boolean</span> b)</span>; </span><br><span class="line"><span class="comment">// 将数据oneByte写入到“PrintStream输出流”中。oneByte虽然是int类型，但实际只会写入一个字节</span></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> oneByte)</span>; </span><br><span class="line"><span class="comment">// 将“buffer中从offset开始的length个字节”写入到“PrintStream输出流”中。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> length)</span>; </span><br></pre></td></tr></table></figure>

<h3 id="System-out-Println"><a href="#System-out-Println" class="headerlink" title="System.out.Println"></a>System.out.Println</h3><ul>
<li><p>out的定义</p>
<p>一个PrintStream实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>out的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initializeSystemClass</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//省略其他代码...</span></span><br><span class="line">  <span class="type">FileOutputStream</span> <span class="variable">fdOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FileDescriptor.out);</span><br><span class="line">  setOut0(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fdOut, <span class="number">128</span>), <span class="literal">true</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>FileDescriptor.out是啥</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FileDescriptor</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> fd;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A handle to the standard output stream. Usually, this file</span></span><br><span class="line"><span class="comment">* descriptor is not used directly, but rather via the output stream</span></span><br><span class="line"><span class="comment">* known as &#123;<span class="doctag">@code</span> System.out&#125;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> java.lang.System#out</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">FileDescriptor</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileDescriptor</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">FileDescriptor</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fd = fd;</span><br><span class="line">    useCount = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileDescriptor.out是一个FileDescriptor实例，其fd&#x3D;1，正是标准输出的标识符。</p>
</li>
<li><p>setOut0方法</p>
<p>setOut0()是一个native本地方法，其功能是设置out为传入的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setOut0</span><span class="params">(PrintStream out)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>System.out.println</p>
<p>所以System.out其实是标准输出的PrintStream实例，而println方法正是调用的PrintStream的println方法。这样PrintStream中的多个输出方法均可以通过System.out调用。</p>
</li>
</ul>
<h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><h2 id="Reader字符输入流"><a href="#Reader字符输入流" class="headerlink" title="Reader字符输入流"></a><code>Reader</code>字符输入流</h2><ul>
<li>BufferedReader<ul>
<li>LineNumberReader</li>
</ul>
</li>
<li>CharArrayReader</li>
<li>FilterReader</li>
<li>PushbackReader</li>
<li>InputStreamReader<ul>
<li>FileReader</li>
</ul>
</li>
<li>PipedReader</li>
<li>StringReader</li>
</ul>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reader</span> <span class="keyword">implements</span> <span class="title class_">Readable</span>, Closeable &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">Reader</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Reader</span><span class="params">(Object lock)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(Charbuffer target)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">markSupported</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readAheadLimit)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h3><p>CharArrayReader 是字符数组输入流。它和<strong>ByteArrayInputStream</strong>类似，只不过ByteArrayInputStream是字节数组输入流，而CharArray是字符数组输入流。CharArrayReader 是用于读取字符数组，它继承于Reader。操作的数据是以字符为单位！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CharArrayReader(<span class="type">char</span>[] buf);</span><br><span class="line">CharArrayReader(<span class="type">char</span>[] buf, <span class="type">int</span> offset, <span class="type">int</span> length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>      <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>      <span class="title function_">mark</span><span class="params">(<span class="type">int</span> readLimit)</span>;</span><br><span class="line"><span class="type">boolean</span>   <span class="title function_">markSupported</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>       <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>       <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">boolean</span>   <span class="title function_">ready</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>      <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line"><span class="type">long</span>      <span class="title function_">skip</span><span class="params">(<span class="type">long</span> charCount)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="PipedReader"><a href="#PipedReader" class="headerlink" title="PipedReader"></a>PipedReader</h3><p>PipedReader 是字符管道输入流，它继承于Writer。</p>
<p>PipedWriter和PipedReader的作用是可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedWriter和PipedReader配套使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PipedReader</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PipedReader</span><span class="params">(<span class="type">int</span> pipeSize)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PipedReader</span><span class="params">(PipedWriter src)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PipedReader</span><span class="params">(PipedWriter src, <span class="type">int</span> pipeSize)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>  <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(PipedWriter src)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span>  <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> off, <span class="type">int</span> len)</span>  <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<h3 id="InpustreamReader"><a href="#InpustreamReader" class="headerlink" title="InpustreamReader"></a>InpustreamReader</h3><p>InputStreamReader和OutputStreamWriter 是字节流通向字符流的桥梁：它使用指定的 charset 读写字节并将其解码为字符。</p>
<p>InputStreamReader 的作用是将“字节输入流”转换成“字符输入流”。它继承于Reader。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in, Charset cs)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in, CharsetDecoder dec)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in, String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEncoding</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>InputStreamReader内部持有一个<code>StreamDecoder sd</code>的私有属性，大部分的功能由<code>StreamDecoder</code>实现。</p>
<h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>FileReader 是用于读取字符流的类，它继承于InputStreamReader。要读取原始字节流，请考虑使用 FileInputStream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(FileDescriptor fd)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>BufferedReader 是缓冲字符输入流。它继承于Reader。</p>
<p>BufferedReader 的作用是为其他字符输入流添加一些缓冲功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader(Reader in);</span><br><span class="line">BufferedReader(Reader in, <span class="type">int</span> size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">mark</span><span class="params">(<span class="type">int</span> markLimit)</span>;</span><br><span class="line"><span class="type">boolean</span>  <span class="title function_">markSupported</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>      <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>      <span class="title function_">read</span><span class="params">(<span class="type">char</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> length)</span>;</span><br><span class="line">String   <span class="title function_">readLine</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span>  <span class="title function_">ready</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line"><span class="type">long</span>     <span class="title function_">skip</span><span class="params">(<span class="type">long</span> charCount)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Writer字符输出流"><a href="#Writer字符输出流" class="headerlink" title="Writer字符输出流"></a><code>Writer</code>字符输出流</h2><ul>
<li>BufferedWriter</li>
<li>CharArrayWriter</li>
<li>FilterWriter</li>
<li>OutputStreamWriter<ul>
<li>FileWriter</li>
</ul>
</li>
<li>PipedWriter</li>
<li>PrintWriter</li>
<li>StringWriter</li>
</ul>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Writer</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable, Flushable &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">Writer</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Writer</span><span class="params">(Object lock)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> Writer <span class="title function_">append</span><span class="params">(Chrequence csq)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> Writer <span class="title function_">apend</span><span class="params">(CharSequence csq, <span class="type">int</span> start, <span class="type">int</span> end)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">public</span> Write <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CharArrayWriter"><a href="#CharArrayWriter" class="headerlink" title="CharArrayWriter"></a>CharArrayWriter</h3><p>CharArrayReader 用于写入数据符，它继承于Writer。操作的数据是以字符为单位！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CharArrayWriter();</span><br><span class="line">CharArrayWriter(<span class="type">int</span> initialSize);</span><br><span class="line"></span><br><span class="line">CharArrayWriter     <span class="title function_">append</span><span class="params">(CharSequence csq, <span class="type">int</span> start, <span class="type">int</span> end)</span>;</span><br><span class="line">CharArrayWriter     <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line">CharArrayWriter     <span class="title function_">append</span><span class="params">(CharSequence csq)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">reset</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"><span class="type">char</span>[]     toCharArray();</span><br><span class="line">String     <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] buffer, <span class="type">int</span> offset, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(<span class="type">int</span> oneChar)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(String str, <span class="type">int</span> offset, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">writeTo</span><span class="params">(Writer out)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="PipedWrite"><a href="#PipedWrite" class="headerlink" title="PipedWrite"></a>PipedWrite</h3><p>PipedWriter 是字符管道输出流，它继承于Writer。</p>
<p>PipedWriter和PipedReader的作用是可以通过管道进行线程间的通讯。在使用管道通信时，必须将PipedWriter和PipedReader配套使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PipedWriter</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PipedWriter</span><span class="params">(PipedReader snk)</span>  <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>  <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(PipedReader snk)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span>  <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><p>InputStreamReader和OutputStreamWriter 是字节流通向字符流的桥梁：它使用指定的 charset 读写字节并将其解码为字符。</p>
<p>OutputStreamWriter 的作用是将“字节输出流”转换成“字符输出流”。它继承于Writer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out, Charset cs)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out, CharsetEecoder enc)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out, String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEncoding</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">write</span><span class="params">(String str, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p>OutputStreamWriter内部持有一个<code>StreamEecoder se</code>的私有属性，大部分的功能由<code>StreamDecoder</code>实现。</p>
<h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><p>FileWriter 是用于写入字符流的类，它继承于OutputStreamWriter。要写入原始字节流，请考虑使用 FileOutputStream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriter</span> <span class="keyword">extends</span> <span class="title class_">OutputStreamWriter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String fileName, <span class="type">boolean</span> append)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName, append));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file, <span class="type">boolean</span> append)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file, append));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(FileDescriptor fd)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h3><p>BufferedWriter 是缓冲字符输出流。它继承于Writer。<br>BufferedWriter 的作用是为其他字符输出流添加一些缓冲功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">BufferedWriter(Writer out); </span><br><span class="line">BufferedWriter(Writer out, <span class="type">int</span> sz); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span>    <span class="title function_">close</span><span class="params">()</span>;                              <span class="comment">// 关闭此流，但要先刷新它。</span></span><br><span class="line"><span class="keyword">void</span>    <span class="title function_">flush</span><span class="params">()</span>;                              <span class="comment">// 刷新该流的缓冲。</span></span><br><span class="line"><span class="keyword">void</span>    <span class="title function_">newLine</span><span class="params">()</span>;                            <span class="comment">// 写入一个行分隔符。</span></span><br><span class="line"><span class="keyword">void</span>    <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span>; <span class="comment">// 写入字符数组的某一部分。</span></span><br><span class="line"><span class="keyword">void</span>    <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span>;                         <span class="comment">// 写入单个字符。</span></span><br><span class="line"><span class="keyword">void</span>    <span class="title function_">write</span><span class="params">(String s, <span class="type">int</span> off, <span class="type">int</span> len)</span>;    <span class="comment">// 写入字符串的某一部分。</span></span><br></pre></td></tr></table></figure>

<h3 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h3><p>PrintWriter 是字符类型的打印输出流，它继承于Writer。</p>
<p>PrintStream 用于向文本输出流打印对象的格式化表示形式。它实现在 <strong>PrintStream</strong> 中的所有 print 方法。它不包含用于写入原始字节的方法，对于这些字节，程序应该使用未编码的字节流进行写入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter(OutputStream out);</span><br><span class="line">PrintWriter(OutputStream out, <span class="type">boolean</span> autoFlush);</span><br><span class="line">PrintWriter(Writer wr);</span><br><span class="line">PrintWriter(Writer wr, <span class="type">boolean</span> autoFlush);</span><br><span class="line">PrintWriter(File file);</span><br><span class="line">PrintWriter(File file, String csn);</span><br><span class="line">PrintWriter(String fileName);</span><br><span class="line">PrintWriter(String fileName, String csn);</span><br><span class="line"></span><br><span class="line">PrintWriter     <span class="title function_">append</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line">PrintWriter     <span class="title function_">append</span><span class="params">(CharSequence csq, <span class="type">int</span> start, <span class="type">int</span> end)</span>;</span><br><span class="line">PrintWriter     <span class="title function_">append</span><span class="params">(CharSequence csq)</span>;</span><br><span class="line"><span class="type">boolean</span>     <span class="title function_">checkError</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line">PrintWriter     <span class="title function_">format</span><span class="params">(Locale l, String format, Object... args)</span>;</span><br><span class="line">PrintWriter     <span class="title function_">format</span><span class="params">(String format, Object... args)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">print</span><span class="params">(<span class="type">float</span> fnum)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">print</span><span class="params">(<span class="type">double</span> dnum)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">print</span><span class="params">(String str)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">print</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">print</span><span class="params">(<span class="type">char</span> ch)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">print</span><span class="params">(<span class="type">char</span>[] charArray)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">print</span><span class="params">(<span class="type">long</span> lnum)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">print</span><span class="params">(<span class="type">int</span> inum)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">print</span><span class="params">(<span class="type">boolean</span> bool)</span>;</span><br><span class="line">PrintWriter     <span class="title function_">printf</span><span class="params">(Locale l, String format, Object... args)</span>;</span><br><span class="line">PrintWriter     <span class="title function_">printf</span><span class="params">(String format, Object... args)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">println</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">println</span><span class="params">(<span class="type">float</span> f)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">println</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">println</span><span class="params">(<span class="type">long</span> l)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">println</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">println</span><span class="params">(<span class="type">char</span>[] chars)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">println</span><span class="params">(String str)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">println</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">println</span><span class="params">(<span class="type">double</span> d)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">println</span><span class="params">(<span class="type">boolean</span> b)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] buf, <span class="type">int</span> offset, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(<span class="type">int</span> oneChar)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] buf)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(String str, <span class="type">int</span> offset, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(String str)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><h2 id="File-1"><a href="#File-1" class="headerlink" title="File"></a>File</h2><p>File 是“<strong>文件</strong>”和“<strong>目录路径名</strong>”的抽象表示形式。</p>
<p>File 直接继承于Object，实现了Serializable接口和Comparable接口。实现Serializable接口，意味着File对象支持序列化操作。而实现Comparable接口，意味着File对象之间可以比较大小；File能直接被存储在有序集合(如TreeSet、TreeMap中)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String pathSeparator; <span class="comment">// 路径分割符&quot;:&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> pathSeparatorChar; <span class="comment">// 路径分割符&#x27;:&#x27;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String separator; <span class="comment">// 分隔符&quot;/&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> separatorChar; <span class="comment">// 分隔符&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">File(File dir, String name);</span><br><span class="line">File(String path);</span><br><span class="line">File(String dirPath, String name);</span><br><span class="line">File(URI uri);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canExecute</span><span class="params">()</span>; <span class="comment">// 测试应用程序是否可以执行此抽象路径名表示的文件。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">()</span>; <span class="comment">// 测试应用程序是否可以读取此抽象路径名表示的文件。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">()</span>; <span class="comment">// 测试应用程序是否可以修改此抽象路径名表示的文件。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(File pathname)</span>; <span class="comment">// 按字母顺序比较两个抽象路径名。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span>; <span class="comment">// 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。</span></span><br><span class="line"><span class="keyword">static</span> File <span class="title function_">createTempFile</span><span class="params">(String prefix, String suffix)</span>; <span class="comment">// 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。</span></span><br><span class="line"><span class="keyword">static</span> File <span class="title function_">createTempFile</span><span class="params">(String prefix, String suffix, File directory)</span>; <span class="comment">// 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span>; <span class="comment">// 删除此抽象路径名表示的文件或目录。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteOnExit</span><span class="params">()</span>; <span class="comment">// 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>; <span class="comment">// 测试此抽象路径名与给定对象是否相等。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>; <span class="comment">// 测试此抽象路径名表示的文件或目录是否存在。</span></span><br><span class="line">File <span class="title function_">getAbsoluteFile</span><span class="params">()</span>; <span class="comment">// 返回此抽象路径名的绝对路径名形式。</span></span><br><span class="line">String <span class="title function_">getAbsolutePath</span><span class="params">()</span>; <span class="comment">// 返回此抽象路径名的绝对路径名字符串。</span></span><br><span class="line">File <span class="title function_">getCanonicalFile</span><span class="params">()</span>; <span class="comment">// 返回此抽象路径名的规范形式。</span></span><br><span class="line">String <span class="title function_">getCanonicalPath</span><span class="params">()</span>; <span class="comment">// 返回此抽象路径名的规范路径名字符串。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getFreeSpace</span><span class="params">()</span>; <span class="comment">// 返回此抽象路径名指定的分区中未分配的字节数。</span></span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span>; <span class="comment">// 返回由此抽象路径名表示的文件或目录的名称。</span></span><br><span class="line">String <span class="title function_">getParent</span><span class="params">()</span>; <span class="comment">// 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。</span></span><br><span class="line">File <span class="title function_">getParentFile</span><span class="params">()</span>; <span class="comment">// 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。</span></span><br><span class="line">String <span class="title function_">getPath</span><span class="params">()</span>; <span class="comment">// 将此抽象路径名转换为一个路径名字符串。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getTotalSpace</span><span class="params">()</span>; <span class="comment">// 返回此抽象路径名指定的分区大小。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getUsableSpace</span><span class="params">()</span>; <span class="comment">// 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>; <span class="comment">// 计算此抽象路径名的哈希码。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAbsolute</span><span class="params">()</span>; <span class="comment">// 测试此抽象路径名是否为绝对路径名。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>; <span class="comment">// 测试此抽象路径名表示的文件是否是一个目录。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>; <span class="comment">// 测试此抽象路径名表示的文件是否是一个标准文件。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isHidden</span><span class="params">()</span>; <span class="comment">// 测试此抽象路径名指定的文件是否是一个隐藏文件。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span>; <span class="comment">// 返回此抽象路径名表示的文件最后一次被修改的时间。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">length</span><span class="params">()</span>; <span class="comment">// 返回由此抽象路径名表示的文件的长度。</span></span><br><span class="line">String[] list(); <span class="comment">// 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。</span></span><br><span class="line">String[] list(FilenameFilter filter); <span class="comment">// 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></span><br><span class="line">File[] listFiles(); <span class="comment">// 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</span></span><br><span class="line">File[] listFiles(FileFilter filter); <span class="comment">// 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></span><br><span class="line">File[] listFiles(FilenameFilter filter); <span class="comment">// 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</span></span><br><span class="line"><span class="keyword">static</span> File[] listRoots(); <span class="comment">// 列出可用的文件系统根。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span>; <span class="comment">// 创建此抽象路径名指定的目录。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span>; <span class="comment">// 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">renameTo</span><span class="params">(File dest)</span>; <span class="comment">// 重新命名此抽象路径名表示的文件。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">setExecutable</span><span class="params">(<span class="type">boolean</span> executable)</span>; <span class="comment">// 设置此抽象路径名所有者执行权限的一个便捷方法。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">setExecutable</span><span class="params">(<span class="type">boolean</span> executable, <span class="type">boolean</span> ownerOnly)</span>; <span class="comment">// 设置此抽象路径名的所有者或所有用户的执行权限。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">setLastModified</span><span class="params">(<span class="type">long</span> time)</span>; <span class="comment">// 设置此抽象路径名指定的文件或目录的最后一次修改时间。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">setReadable</span><span class="params">(<span class="type">boolean</span> readable)</span>; <span class="comment">// 设置此抽象路径名所有者读权限的一个便捷方法。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">setReadable</span><span class="params">(<span class="type">boolean</span> readable, <span class="type">boolean</span> ownerOnly)</span>; <span class="comment">// 设置此抽象路径名的所有者或所有用户的读权限。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">setReadOnly</span><span class="params">()</span>; <span class="comment">// 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">setWritable</span><span class="params">(<span class="type">boolean</span> writable)</span>; <span class="comment">// 设置此抽象路径名所有者写权限的一个便捷方法。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">setWritable</span><span class="params">(<span class="type">boolean</span> writable, <span class="type">boolean</span> ownerOnly)</span>; <span class="comment">// 设置此抽象路径名的所有者或所有用户的写权限。</span></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>; <span class="comment">// 返回此抽象路径名的路径名字符串。</span></span><br><span class="line">URI <span class="title function_">toURI</span><span class="params">()</span>; <span class="comment">// 构造一个表示此抽象路径名的 file: URI。</span></span><br><span class="line">URL <span class="title function_">toURL</span><span class="params">()</span>; <span class="comment">// 已过时。 此方法不会自动转义 URL 中的非法字符。建议新的代码使用以下方式将抽象路径名转换为 URL：首先通过 toURI 方法将其转换为 URI，然后通过 URI.toURL 方法将 URI 装换为 URL。</span></span><br></pre></td></tr></table></figure>
<h2 id="FileDescriptor"><a href="#FileDescriptor" class="headerlink" title="FileDescriptor"></a>FileDescriptor</h2><p>FileDescriptor 是“文件描述符”。<br>FileDescriptor 可以被用来表示开放文件、开放套接字等。<br>以FileDescriptor表示文件来说：当FileDescriptor表示某文件时，我们可以通俗的将FileDescriptor看成是该文件。但是，我们不能直接通过FileDescriptor对该文件进行操作；若需要通过FileDescriptor对该文件进行操作，则需要新创建FileDescriptor对应的FileOutputStream，再对文件进行操作。</p>
<p>FileDescriptor 类中三个类属性<code>in</code>&#x2F;<code>out</code>&#x2F;<code>err</code>，分别为标准输入&#x2F;标准输出&#x2F;标准错误，Java提供了 <code>System.in</code>&#x2F;<code>System.out</code>&#x2F;<code>System.error</code>对应这三个属性，以简化对其的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A handle to the standard input stream. Usually, this file</span></span><br><span class="line"><span class="comment">* descriptor is not used directly, but rather via the input stream</span></span><br><span class="line"><span class="comment">* known as &#123;<span class="doctag">@code</span> System.in&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> java.lang.System#in</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">FileDescriptor</span> <span class="variable">in</span> <span class="operator">=</span> standardStream(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A handle to the standard output stream. Usually, this file</span></span><br><span class="line"><span class="comment">* descriptor is not used directly, but rather via the output stream</span></span><br><span class="line"><span class="comment">* known as &#123;<span class="doctag">@code</span> System.out&#125;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> java.lang.System#out</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">FileDescriptor</span> <span class="variable">out</span> <span class="operator">=</span> standardStream(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A handle to the standard error stream. Usually, this file</span></span><br><span class="line"><span class="comment">* descriptor is not used directly, but rather via the output stream</span></span><br><span class="line"><span class="comment">* known as &#123;<span class="doctag">@code</span> System.err&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> java.lang.System#err</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">FileDescriptor</span> <span class="variable">err</span> <span class="operator">=</span> standardStream(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><p>RandomAccessFile 是随机访问文件(包括读&#x2F;写)的类。它支持对文件随机访问的读取和写入，即我们可以从指定的位置读取&#x2F;写入文件数据。<br>需要注意的是，RandomAccessFile 虽然属于java.io包，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。 FileInputStream 只能对文件进行读操作，而FileOutputStream 只能对文件进行写操作；但是，RandomAccessFile 同时支持文件的读和写，并且它支持随机访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFile</span> <span class="keyword">implements</span> <span class="title class_">DataOutput</span>, DataInput, Closeable &#123;</span><br><span class="line"></span><br><span class="line">    RandomAccessFile(File file, String mode);</span><br><span class="line">    RandomAccessFile(String fileName, String mode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>     <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">final</span> FileChannel     <span class="title function_">getChannel</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> FileDescriptor     <span class="title function_">getFD</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span>     <span class="title function_">getFilePointer</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span>     <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span>     <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> byteOffset, <span class="type">int</span> byteCount)</span>;</span><br><span class="line">    <span class="type">int</span>     <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] buffer)</span>;</span><br><span class="line">    <span class="type">int</span>     <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span>     <span class="title function_">readBoolean</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>     <span class="title function_">readByte</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">char</span>     <span class="title function_">readChar</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">double</span>     <span class="title function_">readDouble</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span>     <span class="title function_">readFloat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[] dst)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[] dst, <span class="type">int</span> offset, <span class="type">int</span> byteCount)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>     <span class="title function_">readInt</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> String     <span class="title function_">readLine</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span>     <span class="title function_">readLong</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">short</span>     <span class="title function_">readShort</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> String     <span class="title function_">readUTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>     <span class="title function_">readUnsignedByte</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>     <span class="title function_">readUnsignedShort</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span>     <span class="title function_">seek</span><span class="params">(<span class="type">long</span> offset)</span>;</span><br><span class="line">    <span class="keyword">void</span>     <span class="title function_">setLength</span><span class="params">(<span class="type">long</span> newLength)</span>;</span><br><span class="line">    <span class="type">int</span>     <span class="title function_">skipBytes</span><span class="params">(<span class="type">int</span> count)</span>;</span><br><span class="line">    <span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(<span class="type">int</span> oneByte)</span>;</span><br><span class="line">    <span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] buffer, <span class="type">int</span> byteOffset, <span class="type">int</span> byteCount)</span>;</span><br><span class="line">    <span class="keyword">void</span>     <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] buffer)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeBoolean</span><span class="params">(<span class="type">boolean</span> val)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeByte</span><span class="params">(<span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeBytes</span><span class="params">(String str)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeChar</span><span class="params">(<span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeChars</span><span class="params">(String str)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeDouble</span><span class="params">(<span class="type">double</span> val)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeFloat</span><span class="params">(<span class="type">float</span> val)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeInt</span><span class="params">(<span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeLong</span><span class="params">(<span class="type">long</span> val)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeShort</span><span class="params">(<span class="type">int</span> val)</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span>     <span class="title function_">writeUTF</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RandomAccessFile共有4种模式：”r”, “rw”, “rws”和”rwd”。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;r&quot;    以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。  </span><br><span class="line">&quot;rw&quot;   打开以便读取和写入。</span><br><span class="line">&quot;rws&quot;  打开以便读取和写入。相对于 &quot;rw&quot;，&quot;rws&quot; 还要求对“文件的内容”或“元数据”的每个更新都同步写入到基础存储设备。  </span><br><span class="line">&quot;rwd&quot;  打开以便读取和写入，相对于 &quot;rw&quot;，&quot;rwd&quot; 还要求对“文件的内容”的每个更新都同步写入到基础存储设备。  </span><br></pre></td></tr></table></figure>

<p><strong>“rw”, “rws”, “rwd” 的区别。</strong><br>  当操作的文件是存储在本地的基础存储设备上时(如硬盘, NandFlash等)，”rws” 或 “rwd”, “rw” 才有区别。<br>  当模式是 “rws” 并且 操作的是基础存储设备上的文件；那么，每次“更改文件内容[如write()写入数据]” 或 “修改文件元数据(如文件的mtime)”时，都会将这些改变同步到基础存储设备上。<br>  当模式是 “rwd” 并且 操作的是基础存储设备上的文件；那么，每次“更改文件内容[如write()写入数据]”时，都会将这些改变同步到基础存储设备上。<br>  当模式是 “rw” 并且 操作的是基础存储设备上的文件；那么，关闭文件时，会将“文件内容的修改”同步到基础存储设备上。至于，“更改文件内容”时，是否会立即同步，取决于系统底层实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sortbylist.github.io/2019/03/26/%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content="Java coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书生小栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/26/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">红黑树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-26 11:08:59" itemprop="dateCreated datePublished" datetime="2019-03-26T11:08:59+08:00">2019-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-01 16:35:09" itemprop="dateModified" datetime="2019-04-01T16:35:09+08:00">2019-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/p/3245399.html">红黑树(一)之 原理和算法详细介绍</a></p>
</blockquote>
<p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<h1 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h1><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意结点的左、右子树也分别为二叉查找树。</li>
<li>没有键值相等的结点（no duplicate nodes）。</li>
</ul>
<p>因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，所以顺理成章，一般操作的执行时间为O（lgn）.（至于n个结点的二叉树高度为lgn的证明，可参考算法导论 第12章 二叉查找树 第12.4节）。</p>
<p>但二叉树若退化成了一棵具有n个结点的线性链后，则此些操作最坏情况运行时间为O（n）。后面我们会看到一种基于二叉查找树-红黑树，它通过一些性质使得树相对平衡，使得最终查找、插入、删除的时间复杂度最坏情况下依然为O（lgn）。</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul>
<li><strong>每个节点或者是黑色，或者是红色。</strong></li>
<li><strong>根节点是黑色。</strong></li>
<li><strong>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</strong></li>
<li><strong>如果一个节点是红色的，则它的子节点必须是黑色的。</strong></li>
<li><strong>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></li>
</ul>
<p>这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>。</p>
<p>要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。</p>
<p><img src="/images/red_black_tree.png" alt="红黑树"></p>
<p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。</p>
<h1 id="红黑树的旋转"><a href="#红黑树的旋转" class="headerlink" title="红黑树的旋转"></a>红黑树的旋转</h1><p>当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。</p>
<p>为了继续保持红黑树的性质，我们可以通过对结点进行重新着色，以及对树进行相关的旋转操作，即修改树中某些结点的颜色及指针结构，来达到对红黑树进行插入或删除结点等操作后，继续保持它的性质或平衡。</p>
<p>树的旋转，分为左旋和右旋</p>
<h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><p><img src="/images/red_black_tree_left.jpg" alt="红黑树左旋"></p>
<p>对x进行左旋，意味着”将x变成一个左节点”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 《算法导论》伪代码</span></span><br><span class="line">LEFT-ROTATE(T, x)  </span><br><span class="line"> y ← right[x]            <span class="comment">// 前提：这里假设x的右孩子为y。下面开始正式操作</span></span><br><span class="line"> right[x] ← left[y]      <span class="comment">// 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子</span></span><br><span class="line"> p[left[y]] ← x          <span class="comment">// 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x</span></span><br><span class="line"> p[y] ← p[x]             <span class="comment">// 将 “x的父亲” 设为 “y的父亲”</span></span><br><span class="line"> <span class="keyword">if</span> p[x] = nil[T]       </span><br><span class="line"> then root[T] ← y                 <span class="comment">// 情况1：如果 “x的父亲” 是空节点，则将y设为根节点</span></span><br><span class="line"> <span class="keyword">else</span> <span class="type">if</span> <span class="variable">x</span> <span class="operator">=</span> left[p[x]]  </span><br><span class="line">           then left[p[x]] ← y    <span class="comment">// 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子”</span></span><br><span class="line">           <span class="keyword">else</span> right[p[x]] ← y   <span class="comment">// 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子”</span></span><br><span class="line"> left[y] ← x             <span class="comment">// 将 “x” 设为 “y的左孩子”</span></span><br><span class="line"> p[x] ← y                <span class="comment">// 将 “x的父节点” 设为 “y”</span></span><br></pre></td></tr></table></figure>

<h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h2><p><img src="/images/red_black_tree_right.jpg" alt="红黑树右旋"></p>
<p>对x进行右旋，意味着”将x变成一个右节点”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 《算法导论》伪代码</span></span><br><span class="line">RIGHT-ROTATE(T, y)  </span><br><span class="line"> x ← left[y]             <span class="comment">// 前提：这里假设y的左孩子为x。下面开始正式操作</span></span><br><span class="line"> left[y] ← right[x]      <span class="comment">// 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子</span></span><br><span class="line"> p[right[x]] ← y         <span class="comment">// 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y</span></span><br><span class="line"> p[x] ← p[y]             <span class="comment">// 将 “y的父亲” 设为 “x的父亲”</span></span><br><span class="line"> <span class="keyword">if</span> p[y] = nil[T]       </span><br><span class="line"> then root[T] ← x                 <span class="comment">// 情况1：如果 “y的父亲” 是空节点，则将x设为根节点</span></span><br><span class="line"> <span class="keyword">else</span> <span class="type">if</span> <span class="variable">y</span> <span class="operator">=</span> right[p[y]]  </span><br><span class="line">           then right[p[y]] ← x   <span class="comment">// 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子”</span></span><br><span class="line">           <span class="keyword">else</span> left[p[y]] ← x    <span class="comment">// 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子”</span></span><br><span class="line"> right[x] ← y            <span class="comment">// 将 “y” 设为 “x的右孩子”</span></span><br><span class="line"> p[y] ← x                <span class="comment">// 将 “y的父节点” 设为 “x”</span></span><br></pre></td></tr></table></figure>

<h1 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h1><p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一颗红黑树。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/03/26/%E7%BA%A2%E9%BB%91%E6%A0%91/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sortbylist.github.io/2018/04/15/Hyper%20&&%20Zsh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content="Java coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书生小栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/15/Hyper%20&&%20Zsh/" class="post-title-link" itemprop="url">Hyper && Zsh</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-15 12:40:05" itemprop="dateCreated datePublished" datetime="2018-04-15T12:40:05+08:00">2018-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-01 16:35:09" itemprop="dateModified" datetime="2019-04-01T16:35:09+08:00">2019-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://medium.com/@nonegrame/%E5%9C%A8-windows10-%E5%AE%89%E8%A3%9D-oh-my-zsh-916105cf36f7">在 windows10 安裝 bash&amp; oh-my-zsh</a></p>
</blockquote>
<h3 id="Win7-without-wsl"><a href="#Win7-without-wsl" class="headerlink" title="Win7 without wsl"></a>Win7 without wsl</h3><ul>
<li><p>下载hyper： <a target="_blank" rel="noopener" href="https://releases.hyper.is/download/win">windows版本</a></p>
</li>
<li><p>中文显示问题 </p>
<p>修改<code>.hyper.js</code> 里面 TermCSS 改成：<code>termCSS: &#39;.wc-node&#123;width: 16px !important&#125;&#39;</code>，或者<code>termCSS: &#39;.wc-node.unicode-node&#123;width: 1em&#125;&#39;</code>,后面一种修改更推荐</p>
</li>
<li><p>hyper-material-theme</p>
<p>修改<code>.hyper.js</code>以下内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [<span class="string">&#x27;hyper-material-theme&#x27;</span>],</span><br><span class="line"></span><br><span class="line"><span class="attr">colors</span>: &#123;..&#125;,</span><br><span class="line"></span><br><span class="line"><span class="title class_">MaterialTheme</span>: &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the theme variant,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTIONS: &#x27;Darker&#x27;, &#x27;Palenight&#x27;, &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">theme</span>: <span class="string">&#x27;Darker&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Optional] Set the rgba() app background opacity, useful when enableVibrance is true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTIONS: From 0.1 to 1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">backgroundOpacity</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Optional] Set the accent color for the current active tab</span></span><br><span class="line"></span><br><span class="line"><span class="attr">accentColor</span>: <span class="string">&#x27;#64FFDA&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Optional] Mac Only. Need restart. Enable the vibrance and blurred background</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OPTIONS: &#x27;dark&#x27;, &#x27;ultra-dark&#x27;, &#x27;bright&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> The backgroundOpacity should be between 0.1 and 0.9 to see the effect.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">vibrancy</span>: <span class="string">&#x27;dark&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Win10-with-wsl"><a href="#Win10-with-wsl" class="headerlink" title="Win10 with wsl"></a>Win10 with wsl</h3><ul>
<li>启用wsl</li>
<li>程序和功能</li>
<li>启用或关闭windows功能</li>
<li>启用适用于Linux的windows子系统</li>
<li>应用商店搜索wsl下载ubuntu并配置账号 </li>
<li>配置hyper启动后登录wsl<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">shell</span>: <span class="string">&#x27;C:\Windows\System32\cmd.exe&#x27;</span>, &lt;---------------- shell: &#x27;&#x27;,</span><br><span class="line"></span><br><span class="line">shellArgs: [&#x27;--login&#x27;, &#x27;-i&#x27;, &#x27;/c wsl&#x27;], &lt;----------------- shellArgs: [&#x27;--login&#x27;],</span><br></pre></td></tr></table></figure></li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/04/15/Hyper%20&&%20Zsh/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sortbylist.github.io/2018/03/15/%E5%8D%9A%E5%AE%A2%E5%A4%8D%E4%B9%A01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content="Java coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书生小栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/15/%E5%8D%9A%E5%AE%A2%E5%A4%8D%E4%B9%A01/" class="post-title-link" itemprop="url">博客复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-15 13:42:15" itemprop="dateCreated datePublished" datetime="2018-03-15T13:42:15+08:00">2018-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-27 16:18:06" itemprop="dateModified" datetime="2020-02-27T16:18:06+08:00">2020-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><ol>
<li><strong>第一范式</strong>：表中不要重复意义的列，每列的值应当有原子性，不可再拆分。</li>
<li><strong>第二范式</strong> ： 数据库表中的每一列都要和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</li>
<li><strong>第三范式</strong>：数据库中的非键列必须相互之前没有关系，完全独立。如果改变一列中的值需要改变另外一列的值，那就是违反了第三范式。</li>
</ol>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ul>
<li><code>DECIMAL</code>精度高于<code>FLOAT</code>和<code>DOUBLE</code></li>
<li><code>FULLTEXT</code>查找通常比<code>LIKE</code>查询要好一些。TEXT类型字段可以利用缓存，而LIKE不行。</li>
<li>如果创建的主键没有任何其他意义和目的，就称其为<code>代理主键</code>。</li>
</ul>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态主要是通过继承来实现的。参数不同，编译时多态，称为重载。子类覆盖父类方法，称为覆写。</p>
<h2 id="ClassLoader类加载器"><a href="#ClassLoader类加载器" class="headerlink" title="ClassLoader类加载器"></a>ClassLoader类加载器</h2><ul>
<li><p>双亲委派机制</p>
<p>在<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的<code>loadClass()</code>方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出<code>ClassNotFoundException</code>异常后，再调用自己的<code>findClass()</code>方法进行加载。</p>
</li>
</ul>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><ul>
<li><p>Heap堆</p>
<p>对象，数组，及对象的实例变量。</p>
<p>堆的优点是动态分配内存大小，生存期也不必事先告诉编译器。缺点是速度较慢。</p>
</li>
<li><p>Stack栈</p>
<p>在函数中定义的基本类型变量和对象的引用变量都在函数的栈内存中分配，方法，局部变量等。</p>
<p>栈的优点是存取速度比堆快，仅次于CPU中的寄存器，另外栈数据可以共享。缺点是存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p>
</li>
</ul>
<h2 id="Java正则"><a href="#Java正则" class="headerlink" title="Java正则"></a>Java正则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;gogo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">patternStr</span> <span class="operator">=</span> <span class="string">&quot;.g.&quot;</span>;</span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(patternStr);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(text);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isExist</span> <span class="operator">=</span> matcher.matches();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFound</span> <span class="operator">=</span> matcher.find();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> matcher.group();</span><br></pre></td></tr></table></figure>

<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul>
<li>字节输入流<code>InputStream</code><ul>
<li><code>FileInputStream</code>&#x2F;<code>ObjectInputStream</code>&#x2F;<code>ByteArrayInputStream</code>&#x2F;<code>BufferedInputStream</code>&#x2F;<code>StringBufferStream</code></li>
</ul>
</li>
<li>字节输出流<code>OutputStream</code><ul>
<li><code>FileOutputStream</code>&#x2F;<code>ObjectOutputStream</code>&#x2F;<code>ByteArrayOutputStream</code>&#x2F;<code>BufferedOutputStream</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Writer</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath, <span class="literal">false</span>));</span><br><span class="line">w.write(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">w.flush();</span><br><span class="line">w.close();</span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath));</span><br><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2048</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((a = is.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">  System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, a));</span><br><span class="line">&#125;</span><br><span class="line">is.close();	</span><br></pre></td></tr></table></figure>

<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><ul>
<li>字符输入流<code>Reader</code><ul>
<li><code>StringReader</code>&#x2F;<code>BufferedRead</code>&#x2F;<code>FileReader</code></li>
</ul>
</li>
<li>字符输出流<code>Writer</code><ul>
<li><code>StringWriter</code>&#x2F;<code>BufferedWriter</code>&#x2F;<code>FileWriter</code></li>
</ul>
</li>
</ul>
<h3 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h3><ul>
<li><code>Throwable</code><ul>
<li><code>Error</code></li>
<li><code>Exception</code><ul>
<li><p><code>RuntimeException</code></p>
</li>
<li><p><code>IOException</code>等</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h3><ul>
<li>接口：<code>Collection</code>(包括<code>List</code>,<code>Set</code>)&#x2F;<code>Map</code></li>
<li>类：<code>ArrayList</code>,<code>HashSet</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>LinkedHashMap</code>,<code>WeakHashMap</code>,<code>ConcurrentHashMap</code></li>
<li><code>ArrayList</code>，数组，允许<code>Null</code>值</li>
<li><code>LinkedList</code>，有序，双向链表，允许<code>Null</code>值</li>
<li><code>HashSet</code>，哈希，链表，允许<code>Null</code>值</li>
<li><code>HashMap</code>,哈希，数组，链表，允许<code>Null</code>键和<code>Null</code>值</li>
<li><code>LinkedHashMap</code>，有序，双向链表，允许<code>Null</code>键和<code>Null</code>值，可实现<code>LRUcache</code>，根据最后使用来排序</li>
<li><code>WeakHashMap</code></li>
<li><code>ConcurrentHashMap</code>，同步，最多支持16并发写</li>
</ul>
<h1 id="进阶复习"><a href="#进阶复习" class="headerlink" title="进阶复习"></a>进阶复习</h1><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013695159">我的阿里之路+Java面经考点</a></p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/03/15/%E5%8D%9A%E5%AE%A2%E5%A4%8D%E4%B9%A01/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sortbylist.github.io/2018/02/09/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content="Java coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书生小栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/02/09/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Git工作流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-09 11:41:02" itemprop="dateCreated datePublished" datetime="2018-02-09T11:41:02+08:00">2018-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-01 16:35:09" itemprop="dateModified" datetime="2019-04-01T16:35:09+08:00">2019-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><ul>
<li><p>分类</p>
<ul>
<li>Git flow</li>
<li>Github flow</li>
<li>Gitlab flow</li>
</ul>
</li>
<li><p>共同点：</p>
<p><strong>功能驱动</strong>：需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。</p>
</li>
</ul>
<h3 id="Git-flow"><a href="#Git-flow" class="headerlink" title="Git flow"></a>Git flow</h3><p>项目存在2个长期分支：</p>
<ul>
<li>主分支master[存放对外发布的版本]</li>
<li>开发分支develop[日常开发的分支]</li>
</ul>
<p>项目存在3种短期分支：</p>
<ul>
<li>功能分支（feature branch）</li>
<li>补丁分支（hotfix branch）</li>
<li>预发分支（release branch）</li>
</ul>
<p>一旦完成开发，它们就会被合并进<code>develop</code>或<code>master</code>，然后被删除。</p>
<p>优点：</p>
<ul>
<li>清晰可控</li>
</ul>
<p>缺点：</p>
<ul>
<li>相对复杂，需要同时维护2个长期分支。大多数工具都将<code>master</code>当作默认分支，可开发在<code>develop</code>分支，导致要经常切换分支。</li>
<li>基于<code>版本发布</code>，目标是一段时间的产出一个新版本。如果是<code>持续发布</code>的项目，代码一有变动，就部署一次。这时<code>master</code>和<code>develop</code>分支差别不大，没必要维护2个长期分支。</li>
</ul>
<h3 id="Github-flow"><a href="#Github-flow" class="headerlink" title="Github flow"></a>Github flow</h3><p>Github flow是git flow的简化版，用于<code>持续发布</code>。</p>
<p>只有1个长期分支<code>master</code>，用起来非常简单。</p>
<p>官方推荐流程：</p>
<blockquote>
<p>第一步：根据需求，从<code>master</code>拉出新分支，不区分功能分支或补丁分支。</p>
<p>第二步：新分支开发完成后，或者需要讨论的时候，就向<code>master</code>发起一个<a target="_blank" rel="noopener" href="https://help.github.com/articles/using-pull-requests/">pull request</a>（简称PR）。</p>
<p>第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。</p>
<p>第四步：一旦你的Pull Request通过评审，并通过测试，就可以部署在生产上，如果出现问题，可以用现有的<code>master</code>分支代码进行回退。</p>
<p>第四步：如果部署在生产上的代码没有问题，那么你的Pull Request将被接受，合并进<code>master</code>。一旦合并（<code>merge</code>），Pull Request就会生成一条<code>commit</code>记录，方便以后搜索与查找。</p>
</blockquote>
<p>优点：</p>
<ul>
<li>简单</li>
<li>适用于<code>持续发布</code>的产品</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>master</code>分支的更新必须与产品的发布一致。但有时候代码合并进<code>master</code>，并不代码它能立刻发布。比如苹果APP审核要时间，或者有些公司有发布窗口。导致线上版本落后于<code>master</code>分支。此时，需要新建一个<code>production</code>分支跟踪线上版本。</li>
</ul>
<h3 id="Gitlab-flow"><a href="#Gitlab-flow" class="headerlink" title="Gitlab flow"></a>Gitlab flow</h3><blockquote>
<p> Gitlab flow 是 Git flow 与 Github flow 的综合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。</p>
</blockquote>
<p>上游优先<code>upsteam first</code>：</p>
<ul>
<li>即存在一个主分支<code>master</code>，它是所有其他分支的<code>上游</code>。只有上游分支采纳的代码变化，才能应用到其他分支。</li>
</ul>
<p>持续发布：</p>
<ul>
<li><code>master</code>分支：开发环境</li>
<li><code>pre-production</code>分支：预发环境</li>
<li><code>production</code>分支：生产环境</li>
</ul>
<blockquote>
<p>开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到<code>master</code>，确认没有问题，再<code>cherry-pick</code>到<code>pre-production</code>，这一步也没有问题，才进入<code>production</code>。</p>
</blockquote>
<blockquote>
<p>只有紧急情况，才允许跳过上游，直接合并到下游分支。</p>
</blockquote>
<p>版本发布：</p>
<ul>
<li><code>master</code>分支：主分支</li>
<li><code>2-3-stable</code>分支：稳定版本分支</li>
</ul>
<blockquote>
<p>只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号（通过打tag方式）。</p>
</blockquote>
<h3 id="个人开发"><a href="#个人开发" class="headerlink" title="个人开发"></a>个人开发</h3><p>建议Gitlab flow</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sortbylist.github.io/2018/02/07/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content="Java coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书生小栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/02/07/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/" class="post-title-link" itemprop="url">持续集成（Continuuous integration，CI）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-07 18:09:08" itemprop="dateCreated datePublished" datetime="2018-02-07T18:09:08+08:00">2018-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-01 16:35:09" itemprop="dateModified" datetime="2019-04-01T16:35:09+08:00">2019-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="持续集成（Continuuous-integration，CI）"><a href="#持续集成（Continuuous-integration，CI）" class="headerlink" title="持续集成（Continuuous integration，CI）"></a>持续集成（Continuuous integration，CI）</h3><blockquote>
<p> 本文为这篇文章笔记：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">持续集成是什么？ - 阮一峰的网络日志</a></p>
</blockquote>
<ul>
<li><p>定义：频繁地（一天多次）将代码集成到主干。</p>
</li>
<li><p>好处：</p>
<ul>
<li>快速发现错误。每完成一点更新，就集成到主干。</li>
<li>防止分支大幅偏离主干。</li>
</ul>
</li>
<li><p>目的：让产品可以快速迭代，同时还能保持高质量。</p>
</li>
<li><p>措施：代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p>
</li>
<li><p>流程：</p>
<ul>
<li><p>提交代码（commit）</p>
</li>
<li><p>第一轮测试</p>
<ul>
<li>自动化，通过代码仓库的钩子（hook）</li>
<li>至少跑一遍<strong>单元测试</strong>（针对函数或模块的测试）</li>
</ul>
</li>
<li><p>构建（将源码转换为可运行的实际代码）</p>
<ul>
<li>代码合并进主干，可以交付</li>
<li>构建工具<ul>
<li><code>Jenkins</code></li>
<li><code>Travis</code></li>
</ul>
</li>
</ul>
</li>
<li><p>第二轮测试</p>
<ul>
<li>全面测试，单元测试和集成测试都要跑</li>
<li>有条件，也要做端对端测试（从用户界面直达数据库的全链路测试）</li>
<li>自动化为主，少数无法自动化的，人工跑。</li>
</ul>
</li>
<li><p>部署</p>
</li>
<li><p>回滚（如果有问题）</p>
</li>
</ul>
</li>
</ul>
<h3 id="持续交付（Continuous-delivery，CD）"><a href="#持续交付（Continuous-delivery，CD）" class="headerlink" title="持续交付（Continuous delivery，CD）"></a>持续交付（Continuous delivery，CD）</h3><ul>
<li>定义：频繁地将软件的新版本，交付给质量团队或用户，以供评审。如果评审通过，就进入生产阶段。</li>
</ul>
<h3 id="持续部署（Continuous-deployment-CD）"><a href="#持续部署（Continuous-deployment-CD）" class="headerlink" title="持续部署（Continuous deployment CD）"></a>持续部署（Continuous deployment CD）</h3><ul>
<li>定义：代码通过评审以后，自动部署到生产环境。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sortbylist.github.io/2018/01/15/RabbitMQ%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content="Java coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书生小栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/15/RabbitMQ%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Rabbitmq入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-15 14:22:23" itemprop="dateCreated datePublished" datetime="2018-01-15T14:22:23+08:00">2018-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-01 16:35:09" itemprop="dateModified" datetime="2019-04-01T16:35:09+08:00">2019-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><ul>
<li>AMQP ( Advance Message Queuing Protocal ) ，高级消息队列协议。是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦。</li>
<li>AMQP的主要特征是面向消息、队列、路由（ 包括点对点和发布&#x2F;订阅 ）、可靠性、安全。</li>
<li>RabbitMQ是一个开源的 AMQP 实现。服务端用 Erlang 语言编写，支持多种客户端，如<code>Python</code>、<code>Java</code>、<code>C</code>等。用于在分布式系统中存储转发消息。</li>
</ul>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul>
<li><p>原理图</p>
<p><img src="/images/rabbitmq.png" alt="rabbitmq"></p>
</li>
<li><p>概念</p>
<ul>
<li><p>server ( broker ) 服务器端</p>
<p>接受客户端连接，实现 AMQP 消息队列和路由功能的进程</p>
</li>
<li><p>producer 生产者</p>
<p>用来创建消息，然后发消息到代理服务器 ( RabbitMQ )。消息包括有效载荷和标签。</p>
</li>
<li><p>consumer 消费者</p>
</li>
<li><p>Virtual Host</p>
<p>这是一个虚拟概念，类似于权限控制组，一个Vitual Host里面可以有若干个Exchange和Queue，但是权限控制的最小粒度是Vitual Host。</p>
</li>
<li><p>Exchange 交换机&#x2F;交易所</p>
<p>所有消息都是发送给它的.由它调度给相应队列。</p>
<p>接收生产者发送的消息，并根据Binding规则将消息路由给服务器中的队列。ExchangeType决定了Exchange路由消息的行为。在RabbitMQ中，ExchangeType有<code>direct</code>、<code>Fanout</code>和<code>Topic</code>三种。</p>
</li>
<li><p>Queue 队列</p>
<p>RabbitMQ内部的消息缓冲器，用于存储还未被消费者消费的消息。</p>
</li>
<li><p>Message 消息</p>
<p>由<code>Header</code>和<code>Body</code>组成，<code>Header</code>是由生产者添加的各种属性的集合，包括Message是否被持久化、由哪个Message Queue接受、优先级是多少等。<code>Body</code>是真正传输的数据。</p>
</li>
<li><p>Binding 绑定规则</p>
<p>将Exchange和Queue绑定起来，通过Routing Key (路由键)。</p>
</li>
<li><p>Routing Key 路由关键字</p>
<p>exchange根据这个关键字进行消息投递。</p>
</li>
<li><p>Connection 连接</p>
<p>一个连接可以创建多个通道.多个通道共享该连接的通道线程池。</p>
</li>
<li><p>Channel 通道</p>
<p>一个通道通常对应一个生产者或一个消费者，否则可能出现bug,通道可以创建若干消费者，所有被创建的消费者共享connection的消费者线程池。</p>
</li>
<li><p>所以，对于消息的过滤，我们首先是指定交易所，然后指定队列和路由。如果需要进一步细分，就可以使用主题。</p>
</li>
</ul>
</li>
<li><p>使用过程</p>
<ul>
<li><strong>消费端</strong><ul>
<li>消费端连接到消息队列服务器，此时建立一个Connection (连接)</li>
<li>打开一个Channel</li>
<li>消费端声明一个Exchange，并设置相关属性</li>
<li>消费端声明一个Queue，并设置相关属性</li>
<li>消费端使用Routing Key，在Exchange和Queue之间建立绑定关系</li>
</ul>
</li>
<li><strong>生产端</strong><ul>
<li>生产端连接到消息队列服务器，此时建立一个Connection(连接)或使用消费端的Connection</li>
<li>打开一个Channel</li>
<li>生产端声明一个Exchange，并设置相关属性</li>
<li>生产端使用Routing Key投递消息到Exchange</li>
<li>Exchange接收到消息后，根据消息的Routing key和已经设置的binding，进行消息路由（ExchangeType起作用），将消息投递到一个或多个队列中</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sortbylist.github.io/2017/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content="Java coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书生小栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9E%E9%A1%BE/" class="post-title-link" itemprop="url">设计模式回顾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-09 11:41:02" itemprop="dateCreated datePublished" datetime="2017-02-09T11:41:02+08:00">2017-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-10 15:24:32" itemprop="dateModified" datetime="2025-02-10T15:24:32+08:00">2025-02-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="创建型模式（5）"><a href="#创建型模式（5）" class="headerlink" title="创建型模式（5）"></a>创建型模式（5）</h5><ul>
<li>工厂方法模式 ( Factory Method ) </li>
<li>抽象工厂模式 ( Abstract Factory ) </li>
<li>单例模式 ( Singleton ) </li>
<li>建造者模式 ( Builder ) </li>
<li>原型模式 ( Prototype )</li>
</ul>
<h5 id="结构型模式（7）"><a href="#结构型模式（7）" class="headerlink" title="结构型模式（7）"></a>结构型模式（7）</h5><ul>
<li>适配器模式 ( Adapter ) </li>
<li>装饰器模式 ( Decorator ) </li>
<li>代理模式 ( Proxy ) </li>
<li>外观模式 ( Facade ) </li>
<li>桥接模式 ( Bridge ) </li>
<li>组合模式 ( Composite ) </li>
<li>享元模式 ( Flyweight )</li>
</ul>
<h5 id="行为型模式（11）"><a href="#行为型模式（11）" class="headerlink" title="行为型模式（11）"></a>行为型模式（11）</h5><ul>
<li>策略模式 ( Strategy ) </li>
<li>模板方法模式 ( Template Method ) </li>
<li>观察者模式 ( Observer ) </li>
<li>迭代器模式 ( Iterator ) </li>
<li>责任链模式 ( Chain of Responsibility ) </li>
<li>命令模式 ( Command ) </li>
<li>备忘录模式 ( Memento ) </li>
<li>中介者模式 ( Mediator ) </li>
<li>解释器模式 ( Interpreter ) </li>
<li>访问者模式 ( Visitor ) </li>
<li>状态模式 ( State )</li>
</ul>
<h4 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h4><ul>
<li><p>单一职责原则(Single Responsibility Principle)</p>
<p>单一职责原则表示一个模块的组成元素之间的功能相关性。从软件变化的角度来看，就一个类而言，应该仅有一个让它变化的原因；通俗地说，即一个类只负责一项职责。</p>
</li>
<li><p>开闭原则（ Open Close principle ) </p>
<blockquote>
<p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p>
</blockquote>
</li>
<li><p>里氏替换原则 ( Liskov Substitution Principle ) </p>
<blockquote>
<p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
</blockquote>
</li>
<li><p>依赖倒转原则 ( Dependence Inversion Principle ) </p>
<p>这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
</li>
<li><p>接口隔离原则 ( Interface Segregation Principle ) </p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还有一个降低类之间的耦合度的意思。</p>
</li>
<li><p>迪米特法则 （最少知道原则 )  ( Demeter Principle ) </p>
<p>一个实体应当尽量少的与其他实体之间发生相互作用，使系统功能模块相对独立。</p>
</li>
<li><p>合成复用原则 ( Composite Reuse Principle ) </p>
<p>尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p>
</li>
</ul>
<h4 id="简单（4）"><a href="#简单（4）" class="headerlink" title="简单（4）"></a>简单（4）</h4><ul>
<li>工厂方法  factory类-&gt;静态方法</li>
<li>抽象工厂  多个factory类 </li>
<li>单例      懒汉&#x2F;饿汉&#x2F;双重检查</li>
<li>建造者    builder</li>
</ul>
<h4 id="有用的（12）"><a href="#有用的（12）" class="headerlink" title="有用的（12）"></a>有用的（12）</h4><ul>
<li>适配器 adapter</li>
<li>装饰器 decorator|wrapper</li>
<li>代理  proxy 静态代理|动态代理</li>
<li>外观 Facade</li>
<li>桥接 bridge</li>
<li>组合 composite</li>
<li>策略  strategy </li>
<li>模板方法 template</li>
<li>观察者 observer</li>
<li>责任链 chain of responsibility</li>
<li>命令 command </li>
<li>状态  state</li>
</ul>
<h4 id="很少使用（7）"><a href="#很少使用（7）" class="headerlink" title="很少使用（7）"></a>很少使用（7）</h4><ul>
<li>原型 prototype</li>
<li>享元 flyweight</li>
<li>迭代器 iterator</li>
<li>备忘录 memento </li>
<li>中介者 mediator </li>
<li>解释器 interperter</li>
<li>访问者 visitor</li>
</ul>
<h4 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式 ( Factory Method )"></a>工厂方法模式 ( Factory Method )</h4><p>建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsSender</span> <span class="keyword">implements</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title function_">produceMail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MailSender</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title function_">produceSms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SmsSender</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line">SendFactory.produceMail().send();</span><br></pre></td></tr></table></figure>

<h5 id="Jdk中的工厂方法模式"><a href="#Jdk中的工厂方法模式" class="headerlink" title="Jdk中的工厂方法模式"></a>Jdk中的工厂方法模式</h5><ul>
<li><code>java.lang.Proxy#newProxyInstance()</code></li>
<li><code>java.lang.Object#toString()</code></li>
<li><code>java.lang.Class#newInstance()</code></li>
<li><code>java.lang.reflect.Array#newInstance()</code></li>
<li><code>java.lang.reflect.Constructor#newInstance()</code></li>
<li><code>java.lang.Boolean#valueOf(String)</code></li>
<li><code>java.lang.Class#forName()</code></li>
</ul>
<h5 id="Mybatis中的工厂方法模式"><a href="#Mybatis中的工厂方法模式" class="headerlink" title="Mybatis中的工厂方法模式"></a>Mybatis中的工厂方法模式</h5><ul>
<li><code>org.apache.ibatis.exceptions.ExceptionFactory</code></li>
<li><code>org.apache.ibatis.logging.LogFactory</code></li>
</ul>
<h4 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式 ( Abstract Factory )"></a>抽象工厂模式 ( Abstract Factory )</h4><p>工厂方法模式的一个问题就是类的创建依赖工厂类，如果要拓展，则需要修改工厂类，违背了开闭原则。使用抽象工厂模式，创建多个工厂类，增加新功能，就直接增加新的工厂类就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Sender <span class="title function_">produce</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsSendFactory</span> <span class="keyword">implements</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Sender <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SmsSender</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailSendFactory</span> <span class="keyword">implements</span> <span class="title class_">Provider</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Sender <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MailSender</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MailSendFactory</span>().produce().send();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">SmsSendFactory</span>().produce().send();</span><br></pre></td></tr></table></figure>

<h5 id="Jdk中的抽象工厂模式"><a href="#Jdk中的抽象工厂模式" class="headerlink" title="Jdk中的抽象工厂模式"></a>Jdk中的抽象工厂模式</h5><ul>
<li>&#96;java.util.Calendar#getInstance()</li>
<li><code>java.util.Arrays#asList()</code></li>
<li><code>java.util.ResourceBundle#getBundle()</code></li>
<li><code>java.sql.DriverManager#getConnection()</code></li>
<li><code>java.sql.Connection#createStatement()</code></li>
<li><code>java.sql.Statement#executeQuery()</code></li>
<li><code>java.text.NumberFormat#getInstance()</code></li>
<li><code>javax.xml.transform.TransformerFactory#newInstance()</code></li>
</ul>
<h5 id="Mybatis中的抽象工厂模式"><a href="#Mybatis中的抽象工厂模式" class="headerlink" title="Mybatis中的抽象工厂模式"></a>Mybatis中的抽象工厂模式</h5><ul>
<li><p><code>org.apache.ibatis.datasource.DataSourceFactory</code></p>
<p><code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code></p>
<p><code>org.apache.ibatis.datasource.pooled.PooledDataSourceFactory</code></p>
<p><code>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory</code></p>
</li>
<li><p><code>org.apache.ibatis.session.SqlSessionFactory</code></p>
<p><code>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultSqlSessionFactory类</span></span><br><span class="line"><span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 ( Singleton )"></a>单例模式 ( Singleton )</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内部类保证调用getInstance()方法时才初始化，同时由jvm保证仅一次初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingleTon</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//防止被实例化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingleTonFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleTon</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingleTonFactory.instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双重校验加volatile，保证jdk5以后不出现指令重排</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingleTon instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingleTon</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (SingleTon.class) &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">SingleTon</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/02/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9E%E9%A1%BE/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sortbylist.github.io/2017/02/09/webservice%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content="Java coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书生小栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/09/webservice%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">WebService基础回顾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-09 11:23:08" itemprop="dateCreated datePublished" datetime="2017-02-09T11:23:08+08:00">2017-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-01 16:35:09" itemprop="dateModified" datetime="2019-04-01T16:35:09+08:00">2019-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a>WebService</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>W3C 组织对其的定义如下，它是一个软件系统，为了支持跨网络的机器间相互操作交互而设计。Web Service 服务通常被定义为一组模块化的 API，它们可以通过网络进行调用，来执行远程系统的请求服务。</p>
</blockquote>
<p>Web Service &#x3D; SOAP + HTTP + WSDL。</p>
<p>其中SOAP （ Simple Object Access Protocol ）协议是 Web Service 主体，它通过 HTTP 或者 SMTP 等应用层协议进行通讯，自身使用 XML  文件来描述程序的函数方法和参数信息，从而完成不同主机的异构系统间的计算服务处理。这里的 WSDL （ Web Service Description Language ）web服务描述语言也是一个 XML 文档，它通过 HTTP 向公众发布，公告客户端程序关于某个具体的 Web Service 服务的 URL 信息、方法的命名、 参数、 返回值等。</p>
<h3 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h3><blockquote>
<p>SOAP 指简单对象访问协议，它是一种基于 XML 的消息通讯格式，用于网络上，不同平台，不同语言的应用程序间的通讯。可自定义，易于扩展。一条 SOAP 消息就是一个普通的 XML 文档，包含下列元素：</p>
<ul>
<li>Envelope 元素，标识 XML 文档一条 SOAP 消息</li>
<li>Header 元素，包含头部信息的 XML 标签</li>
<li>Body 元素，包含所有的调用和响应的主体信息的标签</li>
<li>Fault 元素，错误信息标签。</li>
</ul>
<p>以上的元素都在 SOAP 的命名空间 <a target="_blank" rel="noopener" href="http://www.w3.org/2001/12/soap-envelope">http://www.w3.org/2001/12/soap-envelope</a> 中声明。</p>
</blockquote>
<ul>
<li><p>SOAP 的语法规则</p>
<ul>
<li>SOAP 消息必须用 XML 来编码</li>
<li>SOAP 消息必须使用 SOAP Envelope 命名空间</li>
<li>SOAP 消息必须使用 SOAP Encoding 命名空间</li>
<li>SOAP 消息不能包含 DTD 引用</li>
<li>SOAP 消息不能包含 XML 处理指令</li>
</ul>
</li>
<li><p>SOAP 消息的基本结构</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Header</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Fault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>SOAP Envelope元素<br>Envelope元素是 SOAP 消息的根元素。它指明 XML 文档是一个 SOAP 消息。它的属性 xmlns:soap 的值必须是 <a target="_blank" rel="noopener" href="http://www.w3.org/2001/12/soap-envelope">http://www.w3.org/2001/12/soap-envelope</a>。<br>encodingStyle 属性，语法：soap:encodingStyle&#x3D;”URI”。<br>encodingStyle 属性用于定义文档中使用的数据类型。此属性可出现在任何 SOAP 元素中，并会被应用到元素的内容及元素的所有子元素上。</p>
</li>
<li><p>SOAP Header 元素<br>actor 属性，语法 soap:actor&#x3D;”URI”<br>通过沿着消息路径经过不同的端点， SOAP 消息可从某个发送者传播到某个接收者。并非 SOAP 消息的所有部分均打算传送到 SOAP 消息的最终端点。不过，另一个方面，也许打算传送给消息路径上的一个或多个端点。 SOAP 的 actor 属性可被用于将会Header 元素寻址到一个特定的端点。<br>mustUnderstand 属性，语法 soap:mustUnderstand&#x3D;”0|1”<br>SOAP 的 mustUnderstand 属性可用标识标题项对于要对其进行处理的接收者来说是强制的还是可选的。假如您向Header 元素的某个子元素添加了“mustUnderstand&#x3D;1“，则要求处理头部的接收者必须认可此元素。</p>
</li>
<li><p>SOAP Body 元素<br>必需的 SOAP Body 元素可包含打算传送到消息最终端点的实际 SOAP 消息。Body 元素中既可以包含 SOAP 定义的命名空间中的元素，如 Fault，也可以是用户的应用程序自定义的元素。</p>
</li>
<li><p>SOAP Fault 元素<br>Fault 元素表示 SOAP 的错误消息。它必须是 Body 元素的子元素，且在一条 SOAP 消息中， Fault 元素只能出现一次。Fault 元素拥有下列子元素：</p>
<ul>
<li><code>&lt;faultcode&gt;</code>供识别故障的代码</li>
<li><code>&lt;faultstring&gt;</code>可供人阅读的有关故障的说明</li>
<li><code>&lt;faultactor&gt;</code>有关是谁引发故障的信息</li>
<li><code>&lt;detail&gt;</code>存留涉及 Body 元素的应用程序专用错误信息<br>常用的 SOAP Fault Codes</li>
<li>VersionMismatch SOAP Envelope 元素的无效命名空间</li>
<li>MustUnderstand Header 元素的一个直接子元素（带有设置为”1“的mustUnderstand 属性）无法被理解</li>
<li>Client 消息被不正确的构成，或包含了不正确的信息</li>
<li>Server 服务器有问题，因此无法处理进行下去</li>
</ul>
</li>
<li><p>HTTP 协议中的 SOAP 实例</p>
<ul>
<li><p>SOAP 请求：(注意 HTTP 的 Head 属性)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /InStock HTTP/1.1</span><br><span class="line">Host: www.jsoso.net</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: XXX</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Body</span> <span class="attr">xmlns:m</span>=<span class="string">&quot;http://www.jsoso.net/stock&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">m:GetStockPrice</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m:StockName</span>&gt;</span>IBM<span class="tag">&lt;/<span class="name">m:StockName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">m:GetStockPrice</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SOAP 响应：(注意 HTTP 的 Head 属性)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: XXX</span><br><span class="line"></span><br><span class="line">&lt;? xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:soap</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">soap:encodingStyle</span>=<span class="string">&quot;http://www.w3.org/2001/12/soap-encoding&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">soap:Body</span> <span class="attr">xmlns:m</span>=<span class="string">&quot;http://www.jsoso.net/stock&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">m:GetStockPriceResponse</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">m:Price</span>&gt;</span>34.5<span class="tag">&lt;/<span class="name">m:Price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">m:GetStockPriceResponse</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h3><p>主要元素</p>
<ul>
<li><code>&lt;types&gt;</code> web service 使用的数据类型，它是独立与机器和语言的类型定义，这些数据类型定义被<code>&lt;message&gt;</code>标签所使用。</li>
<li><code>&lt;message&gt;</code> web service 使用的消息，它定义了Web Service函数的参数。在WSDL中，输入参数与输出参数要分开定义，使用不同的<code>&lt;message&gt;</code>标签体标识。<code>&lt;message&gt;</code>标签定义的输出输入参数被<code>&lt;portType&gt;</code>标签使用。</li>
<li><code>&lt;portType&gt;</code> web service 执行的操作。该标签引用<code>&lt;message&gt;</code>标签的定义来描述函数签名（操作名、输入参数、输出参数）。</li>
<li><code>&lt;binding&gt;</code> web service 使用的通信协议。<code>&lt;portType&gt;</code>标签中定义的每一操作在此绑定实现。</li>
<li><code>&lt;service&gt;</code> 该标签确定每一<code>&lt;binding&gt;</code>标签的端口地址。<br>WSDL 文档可分为两个部分。</li>
<li>顶部分由抽象定义组成。抽象部分以独立于平台和语言的方式定义 SOAP 消息，它们并不包含任何随机器或语言而变的元素。这就定义了一系列服务，截然不同的应用都可以实现。<code>&lt;types&gt;</code>、<code>&lt;message&gt;</code>、<code>&lt;portType&gt;</code>属于抽象定义层。所有的抽象可以是单独存在于别的文件中，也可以从主文档中导入。</li>
<li>底部分由具体描述组成。如数据的序列化则可以归入底部分，因为它包含具体的定义。<code>&lt;binding&gt;</code>、<code>&lt;service&gt;</code>属于具体定义层。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://sortbylist.github.io/2017/02/09/java-nio2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jerry Lee">
      <meta itemprop="description" content="Java coder">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="书生小栈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/09/java-nio2/" class="post-title-link" itemprop="url">Java NIO.2 回顾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-09 10:47:58" itemprop="dateCreated datePublished" datetime="2017-02-09T10:47:58+08:00">2017-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-04-01 16:35:09" itemprop="dateModified" datetime="2019-04-01T16:35:09+08:00">2019-04-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="JAVA-NIO-2"><a href="#JAVA-NIO-2" class="headerlink" title="JAVA NIO.2"></a>JAVA NIO.2</h3><blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-nio2-1/">NIO.2 入门，第 1 部分: 异步通道 API</a>、<a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/j-nio2-2/index.html">NIO.2 入门，第 2 部分: 文件系统 API</a></p>
</blockquote>
<ul>
<li>Files</li>
<li>Paths</li>
<li>AsynchronousSocketChannel</li>
<li>AsynchronousServerSocketChannel</li>
<li>AsynchronousDatagramChannel</li>
<li>AsynchronousFileChannel</li>
</ul>
<h4 id="Files、Paths"><a href="#Files、Paths" class="headerlink" title="Files、Paths"></a>Files、Paths</h4><ul>
<li><p>Java 7中三个新的文件系统包</p>
<ul>
<li>java.nio.file</li>
<li>java.nio.file.attribute</li>
<li>java.nio.file.spi</li>
</ul>
</li>
<li><p>最有用的类</p>
<ul>
<li><p><code>java.nio.file.Files</code>、<code>java.nio.file.FileVisitor</code>在特定目录按深度优先遍历算法来查询文件或目录，并可对每个查询结果执行用户实现的回调方法。</p>
</li>
<li><p><code>java.nio.file.Path</code>、<code>java.nio.file.WatchService</code>允许“注册”来监视特定目录。如果在目录中发生了文件创建、修改或者删除操作，监视目录的应用程序将收到通知。</p>
</li>
<li><p><code>java.nio.attribute.*AttributeView</code>允许查询此前对于Java用户隐藏的文件和目录属性，这些属性包括文件所所有 者及组权限，访问控制列表（ACL），以及扩展文件属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FileVisitor&lt;Path&gt; fileVisitor = <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;visit dir[&quot;</span> + dir + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attribs)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;visi file[&quot;</span> + file + <span class="string">&quot;]&#x27;s size=&quot;</span> + attribs.size());</span><br><span class="line">    <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Files.walkFileTree(path, fileVisitor);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>目录监视</p>
<p>WatchService API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WatchService</span> <span class="variable">watchService</span> <span class="operator">=</span> FileSystems.getDefault().newWatchService();</span><br><span class="line"><span class="type">File</span> <span class="variable">watchDirFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;watchDir&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">watchDirPath</span> <span class="operator">=</span> watchDirFile.toPath(); <span class="comment">//FilesSystems.getDefault().getPath(watchDirFile.getPath())</span></span><br><span class="line"><span class="comment">//Path watchDirPath = Paths.get(&quot;watchDir&quot;);</span></span><br><span class="line"><span class="type">WatchKey</span> <span class="variable">watchKey</span> <span class="operator">=</span> watchDirPath.register(watchService, StandardWatchEventKind.ENTRY_CREATE, StandardWatchEventKind.ENTRY_MODIFY);</span><br><span class="line"><span class="comment">//get watchkey</span></span><br><span class="line"><span class="type">WatchKey</span> <span class="variable">watchKey</span> <span class="operator">=</span> watchService.take(); <span class="comment">//blocking //watchService.poll()/watchService.poll(10,TimeUtil.SECONDS);</span></span><br><span class="line"><span class="keyword">for</span>(WatchEvent&lt;?&gt; event : watchKey.pollEvents()) &#123;</span><br><span class="line">  System.out.println(event.kind() +<span class="string">&quot; with &quot;</span> + event.context());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件属性</p>
<p>使用<code>java.nio.file.attribute</code>包中的类获取并设置文件属性。</p>
<p>该包中有7个属性视图（AtrributeView)，其中一些特定于操作系统。</p>
<ul>
<li><p><code>AclFileAttributeView</code>与<code>AclEntry</code></p>
<p>允许设置和获取特定文件的ACL（Access Control List）及文件所有者属性。这些属性视图仅可用于Windows系统。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;c:&quot;, &quot;users&quot;, &quot;download&quot;);</span><br><span class="line">UserPrincipal joe = path.getFileSystem().getUserPrincipalLookupService().lookupPrincipalByName(&quot;joe&quot;);</span><br><span class="line">//get view</span><br><span class="line">AclFileAttributeView view = Files.getFileAttributeView(path, AclFileAttributeView.class);</span><br><span class="line">//create ACE to give &quot;joe&quot; read access</span><br><span class="line">AclEntry entry = AclEntry.newBuilder().setType(AclEntryType.ALLOW)</span><br><span class="line">  .setPrincipal(joe)</span><br><span class="line">  .setPermissions(AclEntryPermission.READ_DATA, AclEntryPermission.READ_ATTRIBUTES)</span><br><span class="line">  .build();</span><br><span class="line">//read ACL, insert ACE, re-write ACL</span><br><span class="line">List&lt;AclEntry&gt; acl = view.getAcl();</span><br><span class="line">acl.add(0, entry); //insert before any DENY entries</span><br><span class="line">view.setAcl(acl);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>BasicFileAttributeView</code>与<code>BasicFileAttributes</code></p>
<p>允许获取一系列“平常的”基本文件属性。其中<code>readAttributes()</code>方法返回一 个<code>BasicFileAttributes</code>实例，该实例包含<code>最后修改时间</code>、<code>最后访问时间</code>、<code>创建时间</code>、<code>大小</code>、以及<code>文件属性</code>等细节（常规文件、目录、符号链接、或者其他）。这一属性视图在所有平台上均可用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;attributeFile&quot;</span>);</span><br><span class="line"><span class="type">BasicFileAttributeView</span> <span class="variable">basicView</span> <span class="operator">=</span> Files.getFileAttributeView(path, BasicFileAttributeView.class);</span><br><span class="line"><span class="type">BasicFileAttribute</span> <span class="variable">basicAttribute</span> <span class="operator">=</span> basiceView.readAttributes();</span><br><span class="line"><span class="type">FileTime</span> <span class="variable">newModTime</span> <span class="operator">=</span> FileTime.fromMillis(basicAttribute.lastModifiedTime().toMillis() + <span class="number">60000</span>);</span><br><span class="line">basicView.setTimes(newModTime, <span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// only update modifyTime</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DosFileAttributeView</code>与<code>DosFileAttributes</code></p>
<p>这一视图类允许您获取指定给 DOS 的属性。（您可能会猜想，这一视图仅用于 Windows 系统。）其 <code>readAttributes()</code> 方法返回一个 <code>DosFileAttributes</code> 实例，该实例包含有问题的文件是否为只读、隐藏、系统文件、以及存档文件等细节信息。这一视图还包含针对每个属性的 <code>set*(boolean)</code> 方法。</p>
</li>
<li><p><code>FileOwnerAttributeView</code>与<code>UserPrincipal</code></p>
<p>这一视图类允许您获取并设置特定文件的所有者。其<code>getOwner()</code>方法返回一个<code>UserPrincipal</code>，其getName()方法，返回所有者名字。该视图还提供<code>setOwner(UserPrincipal)</code>方法用于变更文件所有者。这一属性视图在所有平台上均可用。</p>
</li>
<li><p><code>PosixFileAttributeView </code>与<code>PosixFileAttributes</code></p>
<p>允许获取并设置指定给POSIX（Portable Operationg System Interface）的属性。有关特定文件存储的信息。其<code>readAttributes()</code>方法返回一个包含有关这一文件的所有者、组所有者、以及这一文件许可（这些细节通常用UNIX　chmod命令设置）的<code>PosixFileAttributes</code>实例。这一视图还提供<code>setOwner(UserPrincipal)</code>、<code>setGroup(GroupPrincipal)</code>、以及<code>setPermissions(Set&lt;PosixFilePermission&gt;)</code>来修改这些属性。这一属性视图仅在UNIX系统上可用。</p>
</li>
<li><p><code>FileStoreAttributeView</code>与<code>FileStore</code></p>
<p>允许您获取有关特定文件存储的信息。其 <code>readAttributes()</code> 方法返回一个包含文件存储的整个空间、未分配空间、以及已使用空间细节的 <code>FileStoreSpaceAttributes</code> 实例。这一视图在所有平台上都可用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;c:&quot;</span>);</span><br><span class="line"><span class="type">FileStore</span> <span class="variable">fileStore</span> <span class="operator">=</span> Files.getFileStore(path);</span><br><span class="line">fileStore.getTotalSpace(); </span><br><span class="line">fileStore.getUnallocatedSpace();</span><br><span class="line">fileStore.getUsableSpace();</span><br><span class="line">fileStore.isReadOnly();</span><br><span class="line">fileStore.name();</span><br><span class="line"><span class="type">FileStoreAttributeView</span> <span class="variable">view</span> <span class="operator">=</span> fileStore.getFileStoreAttributeView(FileStoreAttributeView.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UserDefinedFileAttributeView</code></p>
<p>允许您获取并设置文件的<strong>扩展属性</strong>。这些属性跟其他的不同，它们只是名称值对，并可按需对其进行设置。如果想向文件增加一些隐藏的元数据，而不必修改文件内容，这就很有用了。通过<code>list()</code>方法，来返回相关扩展属性的名字列表。然后通过<code>size(String name)</code>返回属性值的大小，通过<code>read(String name, ByteBuffer dst)</code>来将属性值读取到ByteBuffer中，通过<code>write(String name, ByteBuffer source)</code>方法来创建或者修改属性，通过<code>delete(String name)</code>来移除现有属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;c:&quot;</span>);</span><br><span class="line"><span class="type">UserDefinedFileAttributeView</span> <span class="variable">userView</span> <span class="operator">=</span> Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);</span><br><span class="line">List&lt;String&gt; attribList = userView.list();</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">attribValue</span> <span class="operator">=</span> ByteBuffer.allocate(userView.size(attribName));</span><br><span class="line">userView.read(attribName, attribValue); <span class="comment">//读取</span></span><br><span class="line"><span class="type">CharsetDecoder</span> <span class="variable">decoder</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;utf-8&quot;</span>).newDecoder();</span><br><span class="line"><span class="type">CharBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> decoder.decode(attribValue);</span><br><span class="line">userView.write(attribName, attribValue);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="异步通道"><a href="#异步通道" class="headerlink" title="异步通道"></a>异步通道</h4><p>通道API提供2种对已启动异步操作的监测与控制机制。第一种是通过返回<code>java.util.concurrent.Future</code>对象来实现，它将会建模一个挂起操作，并可用于查询其状态以及获取结果。第二种通过传递给操作一个新类的对象<code>java.nio.channels.CompletionHandler</code>来完成，它会定义在操作完毕后所需要执行的内容。</p>
<ul>
<li><p>异步套接字通道及特性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsynchronousServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open();</span><br><span class="line">server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketServer</span>(<span class="number">5555</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Future </span></span><br><span class="line">Future&lt;AsynchronousSocketChannel&gt; acceptFuture = server.accept(); <span class="comment">//立即返回</span></span><br><span class="line"><span class="comment">//if(!future.isDone()) &#123;</span></span><br><span class="line"><span class="comment">//  future.cancel(true);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">while</span>(!future.isDone()); <span class="comment">//waiting</span></span><br><span class="line"><span class="type">AsynchronousSocketChannel</span> <span class="variable">worker</span> <span class="operator">=</span> future.get();</span><br><span class="line"><span class="comment">//AsynchronousSocketChannel worker = future.get(10, TimeUnit.SECONDS); //等待10秒</span></span><br><span class="line"><span class="comment">// read a message from the client</span></span><br><span class="line">worker.read(readBuffer).get(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">System.out.println(<span class="string">&quot;Message: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(readBuffer.array()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//CompletionHandler，第一个参数为accept返回值</span></span><br><span class="line">server.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>(AsynchronousSocketChannel, Void) &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel ch, Void att)</span> &#123;</span><br><span class="line">   server.accept(<span class="literal">null</span>, <span class="built_in">this</span>); <span class="comment">//accept the next connection</span></span><br><span class="line">    <span class="comment">//handle this connection</span></span><br><span class="line">    handle(ch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void att)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"><span class="type">AsynchronousSocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> AsynchronousSocketChannel.open();</span><br><span class="line">client.connect(server.getLocalAddress());</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">message</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;ping&quot;</span>.getBytes());</span><br><span class="line"><span class="type">int</span> <span class="variable">writeLength</span> <span class="operator">=</span> client.write(message).get();</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(Paths.get(<span class="string">&quot;afile&quot;</span>), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.DELETE_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">fileChannel.write(ByteBuffer.wrap(bytes), <span class="number">0</span>, <span class="string">&quot;Write operation 1&quot;</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, Object&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, Object attachment)</span> &#123;</span><br><span class="line">    System.out.println(attachement + <span class="string">&quot; completed with &quot;</span> + result + <span class="string">&quot; bytes Written&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable e, Object attachement)</span> &#123;</span><br><span class="line">    System.err.println(attachment +<span class="string">&quot; fialed with:&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步通道组</p>
<p>每个异步通道都属于一个通道组，它们共享一个Java线程池，该线程池用于完成启动的异步I&#x2F;O操作。<br>默认情况下，具有 <code>open()</code> 方法的通道属于一个全局通道组，可利用如下系统变量对其进行配置：</p>
<ul>
<li><code>java.nio.channels.DefaultThreadPool.threadFactory</code>，其不采用默认设置，而是定义一个 <code>java.util.concurrent.ThreadFactory</code></li>
<li><code>java.nio.channels.DefaultThreadPool.initialSize</code>，指定线程池的初始规模</li>
</ul>
<p><code>java.nio.channels.AsynchronousChannelGroup</code> 中的三个实用方法提供了创建新通道组的方法：</p>
</li>
<li><p><code>withCachedThreadPool()</code></p>
</li>
<li><p><code>withFixedThreadPool()</code></p>
</li>
<li><p><code>withThreadPool()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AsynchronousChannelGroup</span> <span class="variable">tenThreadGroup</span> <span class="operator">=</span> AsynchronousChannelGroup.withFixedThreadPool(<span class="number">10</span>, Executors.defaultThreadFactory());</span><br><span class="line"><span class="type">AysnchronousChannelGroup</span> <span class="variable">tenThreadGroup2</span> <span class="operator">=</span> AsynchronousChannelGroup.withCachedThreadPool(Executors.newCachedThreadPool(), <span class="number">10</span>);</span><br><span class="line"><span class="comment">//使用 tenThreadGroup 而不是默认通道组来获取线程</span></span><br><span class="line"><span class="type">AsynchronousServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> </span><br><span class="line">    AsynchronousServerSocketChannel.open(tenThreadGroup);</span><br></pre></td></tr></table></figure>

<p>利用通道组来控制线程关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">channel.accept(<span class="literal">null</span>, completionHandler);</span><br><span class="line"><span class="keyword">if</span>(!tenThreadGroup.isShutdown()) &#123;</span><br><span class="line">  tenThreadGroup.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!tenThreadGroup.isTerminated()) &#123;</span><br><span class="line">  tenThreadGroup.shutdownNow();</span><br><span class="line">&#125;</span><br><span class="line">tenThreadGroup.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>AsynchronousFileChannel的open()方法使用ExecutorService而不是AsynchronousChannelGroup来实现定制的线程池。</p>
</li>
<li><p>异步数据报通道与多播</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jerry Lee</p>
  <div class="site-description" itemprop="description">Java coder</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/sortbylist" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sortbylist" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerry Lee</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
